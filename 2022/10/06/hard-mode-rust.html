<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Hard Mode Rust</title>
  <meta name="description"
    content="This post is a case study of writing a Rust application using only minimal, artificially constrained API (eg, no dynamic memory allocation).It assumes a fair...">
  <link rel="canonical" href="https://matklad.github.io//2022/10/06/hard-mode-rust.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io//feed.xml">

  <style>
    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Regular.woff2') format('woff2');
    }

    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Bold.woff2') format('woff2');
      ;
      font-weight: bold;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      margin-block-start: 0;
      margin-block-end: 0;
    }

    h1,
    h2,
    h3 {
      font-weight: 300;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    main {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 80ch;
      padding-left: 2ch;
      padding-right: 2ch;
    }

    .site-header {
      width: 100%;
      max-width: 80ch;
      margin-bottom: 1.5rem;
    }

    .site-header>nav {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: baseline;
    }

    .site-header .-title {
      flex-grow: 2;
    }

    .site-footer {
      display: flex;
      justify-content: center;
      align-items: baseline;
      width: 100%;
      max-width: 80ch;
      margin-top: 1rem;
      height: 2rem;
      padding-left: 1ch;
      padding-right: 1ch;
    }
  </style>
  <link rel="stylesheet" href=" /css/adoc.css">
  <link rel="stylesheet" href=" /css/rouge-github.css">
  <link rel="stylesheet" href=" /css/main.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=EB+Garamond:400,400italic,700,700italic%7COpen+Sans:300">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header class="site-header">
    <nav>
      <a class="-title" href="/">matklad</a>
      
      
      <a href="/about/">About</a>
      
      
      
      
      
      <a href="/resume/">Resume</a>
      
      
      
      
      
      
      
      
      
      
    </nav>
  </header>

  <main>
    <article>
  <h1>Hard Mode Rust</h1>
  <div class="post-meta sect1">Oct 6, 2022</div>
  <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This post is a case study of writing a Rust application using only minimal, artificially constrained API (eg, no dynamic memory allocation).
It assumes a fair bit of familiarity with the language.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hard-mode-rust"><a class="anchor" href="#hard-mode-rust"></a>Hard Mode Rust</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The back story here is a particular criticism of Rust and C&#43;&#43; from hard-core C programmers.
This criticism is aimed at <a href="https://en.cppreference.com/w/cpp/language/raii">RAII</a>&#8201;&#8212;&#8201;the language-defining feature of C&#43;&#43;, which was wholesale imported to Rust as well.
RAII makes using various resources requiring cleanups (file descriptors, memory, locks) easy&#8201;&#8212;&#8201;any place in the program can create a resource, and the cleanup code will be invoked automatically when needed.
And herein lies the problem&#8201;&#8212;&#8201;because allocating resources becomes easy, RAII encourages a sloppy attitude to resources, where they are allocated and destroyed all over the place.
In particular, this leads to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Decrease in reliability. Resources are usually limited in principle, but actual resource exhaustion happens rarely.
If resources are allocated throughout the program, there are many virtually untested codepaths.</p>
</li>
<li>
<p>Lack of predictability. It usually is impossible to predict up-front how much resources will the program consume.
Instead, resource-consumption is observed empirically.</p>
</li>
<li>
<p>Poor performance. Usually, it is significantly more efficient to allocate and free resources in batches.
Cleanup code for individual resources is scattered throughout codebase, increasing code bloat</p>
</li>
<li>
<p>Spaghetti architecture. Resource allocation is an architecturally salient thing.
If all resource management is centralized to a single place, it becomes significantly easier to understand lifecycle of resources.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I think this is a fair criticism.
In fact, I think this is the same criticism that C&#43;&#43; and Rust programmers aim at garbage collected languages.
This is a spectrum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre>           GC object graph
                 v v
                  v
        Tree of values with RAII
                 v v
                  v
Static allocation of resources at startup
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Rust programmers typically are not exposed to the lowest level of this pyramid.
But there&#8217;s a relatively compact exercise to gain the relevant experience: try re-implementing your favorite Rust programs on hard mode.</p>
</div>
<div class="paragraph">
<p><strong>Hard Mode</strong> means that you split your program into <code>std</code> binary and <code>#![no_std]</code> no-alloc library.
Only the small binary is allowed to directly ask OS for resources.
For the library, all resources must be injected.
In particular, to do memory allocation, the library receives a slice of bytes of a fixed size, and should use that for all storage.
Something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="c1">// app/src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">mem_limit</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">memory</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="n">mem_limit</span><span class="p">];</span>
  <span class="nn">app</span><span class="p">::</span><span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">memory</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// app/src/lib.rs</span>
<span class="nd">#![no_std]</span> <span class="c1">// &lt;- the point of the exercise</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">memory</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ray-tracing"><a class="anchor" href="#ray-tracing"></a>Ray Tracing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So, this is what the post is about: my experience implementing a toy hard mode ray tracer.
You can find the code on GitHub: <a href="http://github.com/matklad/crt" class="bare">http://github.com/matklad/crt</a>.</p>
</div>
<div class="paragraph">
<p>The task of a ray tracer is to convert a description of a 3D scene like the following one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="code"><pre>background #000000

camera {
    pos 0,10,-50
    look_at 0,0,0
    up 0,-1,0
    focus 50
    dim 80x60
}

light {
    pos -20,10,0
    color #aa1111
}

plane {
    pos 0,-10,0
    normal 0,1,0
    material {
        color #5566FF
        diffuse 3
    }
}

mesh {
    material {
        color #BB5566
        diffuse 3
    }

    data {
        v 5.92,4.12,0.00
        v 5.83,4.49,0.00
        v 5.94,4.61,0.00
        v 6.17,4.49,0.00
        v 6.42,4.12,0.00
        v 5.38,4.12,2.74
        ...

        vn -0.96,-0.25,0.00
        vn -0.96,0.25,0.00
        vn -0.09,0.99,0.00
        vn 0.68,0.73,0.00
        vn 0.87,0.49,0.00
        vn -0.89,-0.25,-0.36
        ...

        f 1/1 2/2 3/3
        f 4/4 5/5 6/6
        ...
    }

}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Into a rendered image like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://user-images.githubusercontent.com/1711539/194287665-05583649-dcb0-4014-82b9-424f945e19a4.png" alt="194287665 05583649 dcb0 4014 82b9 424f945e19a4">
</div>
</div>
<div class="paragraph">
<p>This works rather intuitive conceptually.
First, imagine the above scene, with an infinite fuchsia colored plane and a red Utah teapot hovering above that.
Then, imagine a camera standing at <code>0,10,-50</code> (in cartesian coordinates) and aiming at the origin.
Now, draw an imaginary rectangular 80x60 screen at a focus distance of 50 from the camera along its line of side.
To get a 2D picture, we shoot a ray from the camera through each &#8220;pixel&#8221; on the screen, note which object on the scene is hit (plan, teapot, background), and color the pixel accordingly.
See <a href="https://pbrt.org">PBRT Book</a> if you feel like falling further into this particular rabbit hole (warning: it is very deep) (I apologize for &#8220;little square pixels&#8221; simplification I use throughout the post :-) ).</p>
</div>
<div class="paragraph">
<p>I won&#8217;t focus on specific algorithms to implement that (indeed, crt is a very naive tracer), but rather highlight Hard Mode Rust specific concerns.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pixel-buffer"><a class="anchor" href="#pixel-buffer"></a>Pixel Buffer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ultimately, the out of a ray tracer is a 2D buffer with 8bit RGB pixels.
One would typically represent it as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">r</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">u8</span> <span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Buf</span> <span class="p">{</span>
  <span class="n">dim</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">2</span><span class="p">]</span>
  <span class="c1">// invariant: data.len() == dim.0 * dim.1</span>
  <span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="n">Color</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For us, we want someone else (main) to allocate that box of colors for us, so instead we do the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">dim</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Color</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">dim</span><span class="p">:</span> <span class="n">Idx</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Color</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">dim</span><span class="na">.0</span> <span class="o">*</span> <span class="n">dim</span><span class="na">.1</span> <span class="o">==</span> <span class="n">buf</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">);</span>
    <span class="n">Buf</span> <span class="p">{</span> <span class="n">dim</span><span class="p">,</span> <span class="n">buf</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>'m</code> lifetime we use for abstract memory managed elsewhere.
Note how the struct grew an extra lifetime!
This is extra price we have to pay for not relying on RAII to cleanup resources for us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="c1">// Easy Mode</span>
<span class="k">fn</span> <span class="nf">paint</span><span class="p">(</span><span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Buf</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">struct</span> <span class="n">PaintCtx</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">Buf</span>
<span class="p">}</span>

<span class="c1">// Hard Mode</span>
<span class="k">fn</span> <span class="nf">paint</span><span class="p">(</span><span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">struct</span> <span class="n">PaintCtx</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note in particular how the <code>Ctx</code> struct now has to include two lifetimes.
This feels unnecessary: <code>'a</code> is shorter than <code>'m</code>.
I wish it was possible to somehow abstract that away:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">PaintCtx</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="c1">// &amp;'a mut exists&lt;'m&gt;: Buf&lt;'m&gt;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>I don&#8217;t think that&#8217;s really possible (<a href="https://matklad.github.io/2018/05/04/encapsulating-lifetime-of-the-field.html">earlier post about this</a>).
In particular, the following would run into variance issues:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">PaintCtx</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ultimately, this is annoying, but not a deal breaker.</p>
</div>
<div class="paragraph">
<p>With this <code>rbg::Buf&lt;'_&gt;</code>, we can sketch the program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre><span class="c1">// hard mode library</span>
<span class="nd">#![no_std]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">render</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">crt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>   <span class="c1">// textual description of the scene</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="c1">// all the memory we can use</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">rgb</span><span class="p">::</span><span class="n">Buf</span><span class="p">,</span> <span class="c1">// write image here</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>

<span class="c1">// main</span>
<span class="nd">#[derive(argh::FromArgs)]</span>
<span class="k">struct</span> <span class="n">Args</span> <span class="p">{</span>
  <span class="nd">#[argh(option,</span> <span class="nd">default</span> <span class="nd">=</span> <span class="s">"64"</span><span class="nd">)]</span>  <span class="n">mem</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="nd">#[argh(option,</span> <span class="nd">default</span> <span class="nd">=</span> <span class="s">"800"</span><span class="nd">)]</span> <span class="n">width</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="nd">#[argh(option,</span> <span class="nd">default</span> <span class="nd">=</span> <span class="s">"600"</span><span class="nd">)]</span> <span class="n">height</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span> <span class="o">=</span> <span class="nn">argh</span><span class="p">::</span><span class="nf">from_env</span><span class="p">();</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">crt</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span>
    <span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">crt</span><span class="p">)</span>
    <span class="nf">.context</span><span class="p">(</span><span class="s">"reading input"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

  <span class="c1">// Allocate all the memory.</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">mem</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">args</span><span class="py">.mem</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">];</span>

  <span class="c1">// Allocate the image</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
    <span class="nn">rgb</span><span class="p">::</span><span class="nn">Color</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="p">(</span><span class="n">args</span><span class="py">.width</span> <span class="o">*</span> <span class="n">args</span><span class="py">.height</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span>
  <span class="p">];</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span>
    <span class="nn">rgb</span><span class="p">::</span><span class="nn">Buf</span><span class="p">::</span><span class="nf">new</span><span class="p">([</span><span class="n">args</span><span class="py">.width</span><span class="p">,</span> <span class="n">args</span><span class="py">.height</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">);</span>

  <span class="nn">render</span><span class="p">::</span><span class="nf">render</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="n">crt</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="n">mem</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">,</span>
  <span class="p">)</span>
  <span class="nf">.map_err</span><span class="p">(|</span><span class="n">err</span><span class="p">|</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nd">format_err!</span><span class="p">(</span><span class="s">"{err}"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

  <span class="c1">// Write result as a PPM image format.</span>
  <span class="nf">write_ppm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">io</span><span class="p">::</span><span class="nf">stdout</span><span class="p">()</span><span class="nf">.lock</span><span class="p">())</span>
    <span class="nf">.context</span><span class="p">(</span><span class="s">"writing output"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">write_ppm</span><span class="p">(</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">rgb</span><span class="p">::</span><span class="n">Buf</span><span class="p">,</span>
  <span class="n">w</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">dyn</span> <span class="nn">io</span><span class="p">::</span><span class="n">Write</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hard-mode-rayon"><a class="anchor" href="#hard-mode-rayon"></a>Hard Mode Rayon</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ray tracing is an embarrassingly parallel task&#8201;&#8212;&#8201;the color of each output pixel can be computed independently.
Usually, the excellent <a href="https://lib.rs/crates/rayon">rayon</a> library is used to take advantage of parallelism, but for our raytracer I want to show a significantly simpler API design for taking advantage of many cores.
I&#8217;ve seen this design in <a href="https://github.com/sorbet/sorbet/blob/master/common/concurrency/WorkerPool.h">Sorbet</a>, a type checker for Ruby.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s how a <code>render</code> function with support for parallelism looks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="hll"><span class="k">type</span> <span class="n">ThreadPool</span><span class="o">&lt;</span><span class="nv">'t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Sync</span><span class="p">))</span> <span class="o">+</span> <span class="nv">'t</span><span class="p">;</span>
</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">render</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">crt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
<span class="hll">  <span class="n">in_parallel</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ThreadPool</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
</span>  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">rgb</span><span class="p">::</span><span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface here is the <code>in_parallel</code> function, which takes another function as an argument and runs it, in parallel, on all available threads.
You typically use it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">work</span><span class="p">:</span> <span class="n">ConcurrentQueue</span><span class="o">&lt;</span><span class="n">Work</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">ConcurrentQueue</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="n">work</span><span class="nf">.extend</span><span class="p">(</span><span class="n">available_work</span><span class="p">);</span>
<span class="nf">in_parallel</span><span class="p">(</span><span class="o">&amp;</span><span class="p">||</span> <span class="p">{</span>
  <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">=</span> <span class="n">work</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">process</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is <em>similar</em> to a typical threadpool, but different.
Similar to a threadpool, there&#8217;s a number of threads (typically one per core) which execute arbitrary jobs.
The first difference is that a typical threadpool sends a job to to a single thread, while in this design the same job is broadcasted to all threads.
The job is <code>Fn + Sync</code> rather than <code>FnOnce + Send</code>.
The second difference is that we <em>block</em> until the job is done on all threads, so we can borrow data from the stack.</p>
</div>
<div class="paragraph">
<p>It&#8217;s on the caller to explicitly implement a concurrent queue to distributed specific work items.
In my implementation, I slice the image in rows</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="k">type</span> <span class="n">ThreadPool</span><span class="o">&lt;</span><span class="nv">'t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Sync</span><span class="p">))</span> <span class="o">+</span> <span class="nv">'t</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">render</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">crt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
  <span class="n">in_parallel</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ThreadPool</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">rgb</span><span class="p">::</span><span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="c1">// Note: this is not mut, because this is</span>
  <span class="c1">// a concurrent iterator.</span>
  <span class="k">let</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">buf</span><span class="nf">.partition</span><span class="p">();</span>
  <span class="nf">in_parallel</span><span class="p">(</span><span class="o">&amp;</span><span class="p">||</span> <span class="p">{</span>
    <span class="c1">// next_row increments an atomic and</span>
    <span class="c1">// uses the row index to give an `&amp;mut`</span>
    <span class="c1">// into the row's pixels.</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">=</span> <span class="n">rows</span><span class="nf">.next_row</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="n">row</span><span class="py">.y</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nn">rgb</span><span class="p">::</span><span class="n">Color</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="py">.buf</span><span class="p">;</span>
      <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">color</span> <span class="o">=</span> <span class="nn">render</span><span class="p">::</span><span class="nf">render_pixel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scene</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]);</span>
        <span class="n">buf</span><span class="p">[</span><span class="n">x</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="nf">to_rgb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">color</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">});</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In <code>main</code>, we implement a concrete <code>ThreadPool</code> by spawning a thread per core:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="k">let</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">match</span> <span class="n">args</span><span class="py">.jobs</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Threads</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">it</span><span class="p">),</span>
    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nn">Threads</span><span class="p">::</span><span class="nf">with_max_threads</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="nn">render</span><span class="p">::</span><span class="nf">render</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="n">crt</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="n">mem</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="p">|</span><span class="n">f</span><span class="p">|</span> <span class="n">threads</span><span class="nf">.in_parallel</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">,</span>
  <span class="p">)</span>
  <span class="nf">.map_err</span><span class="p">(|</span><span class="n">err</span><span class="p">|</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nd">format_err!</span><span class="p">(</span><span class="s">"{err}"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="allocator"><a class="anchor" href="#allocator"></a>Allocator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The scenes we are going to render are fundamentally dynamically sized.
They can contain arbitrary number of objects.
So we can&#8217;t just statically allocate all the memory up-front.
Instead, there&#8217;s a CLI argument which sets the amount of memory a ray tracer can use, and we should either manage with that, or return an error.
So we do need to write our own allocator.
But we&#8217;ll try very hard to only allocate the memory we actually need, so we won&#8217;t have to implement memory deallocation at all.
So a simple bump allocator would do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">raw</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Oom</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">raw</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Mem</span> <span class="p">{</span> <span class="n">raw</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="n">alloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="n">alloc_array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">mut</span> <span class="n">element</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="n">alloc_array_default</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Default</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.alloc_array</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">|</span><span class="n">_</span><span class="p">|</span> <span class="nn">T</span><span class="p">::</span><span class="nf">default</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can create an allocator from a slice of bytes, and then ask it to allocate values and arrays.
Schematically, <code>alloc</code> looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="c1">// PSEUDOCODE, doesn't handle alignment and is broken.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">alloc</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
  <span class="n">val</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">if</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="p">{</span>
    <span class="c1">// Return error if there isn't enough of memory.</span>
    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">Oom</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Split off size_of::&lt;T&gt; bytes from the start,</span>
  <span class="c1">// doing a little `mem::take` dance to placate</span>
  <span class="c1">// the borrowchecker.</span>
  <span class="k">let</span> <span class="n">res</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">raw</span> <span class="o">=</span> <span class="nn">mem</span><span class="p">::</span><span class="nf">take</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.raw</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">raw</span><span class="p">)</span> <span class="o">=</span> <span class="n">raw</span><span class="nf">.split_at_mut</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.raw</span> <span class="o">=</span> <span class="n">raw</span><span class="p">;</span>
    <span class="n">res</span>
  <span class="p">}</span>

  <span class="c1">// Initialize the value</span>
  <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="nn">ptr</span><span class="p">::</span><span class="nf">write</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To make this fully kosher we need to handle alignment as well, but I cut that bit out for brevity.</p>
</div>
<div class="paragraph">
<p>For allocating arrays, it&#8217;s useful if all-zeros bitpattern is a valid default instance of type, as that allows to skip element-wise initialization.
This condition isn&#8217;t easily expressible in today&#8217;s Rust though, so we require initializing every array member.</p>
</div>
<div class="paragraph">
<p>The result of an allocation is <code>&amp;'m T</code>&#8201;&#8212;&#8201;this is how we spell <code>Box&lt;T&gt;</code> on hard mode.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parsing"><a class="anchor" href="#parsing"></a>Parsing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The scene contains various objects, like spheres and planes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Sphere</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">center</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span> <span class="c1">// v64 is [f64; 3]</span>
  <span class="k">pub</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Plane</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">origin</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">normal</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Usually, we&#8217;d represent a scene as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Scene</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">spheres</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Sphere</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">planes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Plane</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We <em>could</em> implement a resizable array (<code>Vec</code>), but doing that would require us to either leak memory, or to implement proper deallocation logic in our allocator, and add destructors to reliably trigger that.
But destructors is exactly something we are trying to avoid in this exercise.
So our scene will have to look like this instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Scene</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">spheres</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Sphere</span><span class="p">],</span>
  <span class="k">pub</span> <span class="n">planes</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Plane</span><span class="p">],</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And that means we want to know the number of objects we&#8217;ll need upfront.
The way we solve this problem is by doing two-pass parsing.
In the first pass, we just count things, then we allocate them, then we actually parse them into allocated space.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">fn</span> <span class="n">parse</span><span class="o">&lt;</span><span class="nv">'m</span><span class="p">,</span> <span class="nv">'i</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'i</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Scene</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Error</span><span class="o">&lt;</span><span class="nv">'i</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="c1">// Size the allocations.</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">n_spheres</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">n_planes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">input</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">word</span> <span class="p">{</span>
      <span class="s">"sphere"</span> <span class="k">=&gt;</span> <span class="n">n_spheres</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">,</span>
      <span class="s">"plane"</span> <span class="k">=&gt;</span> <span class="n">n_planes</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">,</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(),</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Allocate.</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="n">Scene</span> <span class="p">{</span>
    <span class="n">camera</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
    <span class="n">spheres</span><span class="p">:</span> <span class="n">mem</span><span class="nf">.alloc_array_default</span><span class="p">(</span><span class="n">n_spheres</span><span class="p">)</span><span class="o">?</span>
    <span class="n">planes</span><span class="p">:</span> <span class="n">mem</span><span class="nf">.alloc_array_default</span><span class="p">(</span><span class="n">n_planes</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="c1">// Parse _into_ the allocated scene.</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">Parser</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
  <span class="nf">scene</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">res</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="nf">Ok</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>If an error is encountered during parsing, we want to create a helpful error message.
If the message is fully dynamic, we&#8217;d have to allocate it <em>into</em> <code>'m</code>, but it seems simpler to just re-use bits of input for error message.
Hence, <code>Error&lt;'i&gt;</code> is tied to the input lifetime <code>'i</code>, rather memory lifetime <code>'m</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="nested-objects"><a class="anchor" href="#nested-objects"></a>Nested Objects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One interesting type of object on the scene is a mesh of triangles (for example, the teapot is just a bunch of triangles).
A naive way to represent a bunch of triangles is to use a vector:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Triangle</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">a</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">b</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">c</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Mesh</span> <span class="o">=</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Triangle</span><span class="o">&gt;</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is wasteful: in a mesh, each edge is shared by two triangles.
So a single vertex belongs to a bunch of triangles.
If we store a vector of triangles, we are needlessly duplicating vertex data.
A more compact representation is to store unique vertexes once, and to use indexes for sharing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Mesh</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">vertexes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">v64</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">faces</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">MeshFace</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="c1">// Indexes point into vertexes vector.</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MeshFace</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">u32</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, on hard mode that would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Mesh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">vertexes</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">v64</span><span class="p">],</span>
  <span class="k">pub</span> <span class="n">faces</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">MeshFace</span><span class="p">],</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And a scene contains a bunch of meshes :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Scene</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">spheres</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Sphere</span><span class="p">],</span>
  <span class="k">pub</span> <span class="n">planes</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Plane</span><span class="p">],</span>
  <span class="k">pub</span> <span class="n">meshes</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Mesh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">],</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how, if the structure is recursive, we have &#8220;owned pointers&#8221; of <code>&amp;'m mut T&lt;'m&gt;</code> shape.
Originally I worried that that would cause problem with variance, but it seems to work fine for ownership specifically.
During processing, you still need <code>&amp;'a mut T&lt;'m&gt;</code> though.</p>
</div>
<div class="paragraph">
<p>And that&#8217;s why parsing functions hold an uncomfortable bunch of lifetimes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="n">mesh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="p">,</span> <span class="nv">'i</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="nv">'m</span><span class="p">,</span> <span class="nv">'i</span><span class="p">,</span> <span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">res</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mesh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&lt;</span><span class="nv">'i</span><span class="o">&gt;&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The parser <code>p</code> holds <code>&amp;'i str</code> input and a <code>&amp;'a mut Mem&lt;'m&gt;</code> memory.
It parses input <em>into</em> a <code>&amp;'b mut Mesh&lt;'m&gt;</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bounding-volume-hierarchy"><a class="anchor" href="#bounding-volume-hierarchy"></a>Bounding Volume Hierarchy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With <code>Scene&lt;'m&gt;</code> fully parsed, we can finally get to rendering the picture.
A naive way to do this would be to iterate through each pixel, shooting a ray through it, and then do a nested iterations over every shape, looking for the closest intersection.
That&#8217;s going to be slow!
The teapot model contains about 1k triangles, and we have 640*480 pixels, which gives us 307_200_000 ray-triangle intersection tests, which is quite slow even with multithreading.</p>
</div>
<div class="paragraph">
<p>So we are going to speed this up.
The idea is simple&#8201;&#8212;&#8201;just don&#8217;t intersect a ray with each triangle.
It is possible to quickly discard batches of triangles.
If we have a  batch of triangles, we can draw a 3D box around them as a pre-processing step.
Now if the ray doesn&#8217;t intersect the bounding box, we know that it can&#8217;t intersect any of the triangles.
So we can use one test with a bounding box instead of many tests for each triangle.</p>
</div>
<div class="paragraph">
<p>This is of course one-sided&#8201;&#8212;&#8201;if the ray intersects the box, it might still miss all of the triangles.
But, if we place bounding boxes smartly (small boxes which cover many adjacent triangles), we can hope to skip a lot of work.</p>
</div>
<div class="paragraph">
<p>We won&#8217;t go for really smart ways of doing that, and instead will use a simple divide-and-conquer scheme.
Specifically, we&#8217;ll draw a large box around all triangles we have.
Then, we&#8217;ll note which dimension of the resulting box is the longest.
If, for example, the box is very tall, we&#8217;ll cut it in half horizontally, such that each half contains half of the triangles.
Then, we&#8217;ll recursively subdivide the two halves.</p>
</div>
<div class="paragraph">
<p>In the end, we get a binary tree, where each node contains a bounding box and two children, whose bounding boxes are contained in the parent&#8217;s bounding box.
Leaves contains triangles.
This construction is called a bounding volume hierarchy, bvh.</p>
</div>
<div class="paragraph">
<p>To intersect the ray with bvh, we use a recursive procedure.
Starting at the root node, we descend into children whose bounding boxes are intersected by the ray.
Sometimes we&#8217;ll have to descent into both children, but often enough at least one child&#8217;s bounding box won&#8217;t touch the ray, allowing us to completely skip the subtree.</p>
</div>
<div class="paragraph">
<p>On easy mode Rust, we can code it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">BoundingBox</span> <span class="p">{</span>
  <span class="c1">// Opposite corners of the box.</span>
  <span class="n">lo</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span> <span class="n">hi</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Bvh</span> <span class="p">{</span>
  <span class="n">root</span><span class="p">:</span> <span class="n">BvhNode</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">BvhNode</span> <span class="p">{</span>
  <span class="n">Split</span> <span class="p">{</span>
    <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
    <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">BvhNode</span><span class="o">&gt;</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span>
    <span class="cd">/// Which of X,Y,Z dimensions was used</span>
    <span class="c1">// to cut the bb in two.</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="n">Leaf</span> <span class="p">{</span>
    <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
    <span class="cd">/// Index of the triangle in a mesh.</span>
    <span class="n">triangle</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>On hard mode, we don&#8217;t really love all those separate boxes, we love arrays!
So what we&#8217;d rather have is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Bvh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">splits</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">BvhSplit</span><span class="p">],</span>
  <span class="n">leaves</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">BvhLeaf</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">BvhSplit</span> <span class="p">{</span>
  <span class="cd">/// Index into either splits or leaves.</span>
  <span class="cd">/// The `tag` is in the highest bit.</span>
  <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span>
  <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
  <span class="n">axis</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">BvhLeaf</span> <span class="p">{</span>
  <span class="n">face</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>So we want to write the following function which recursively constructs a bvh for a mesh:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">build</span><span class="p">(</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">mesh</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Mesh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Bvh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is, unlike the parser, we can&#8217;t cheaply determine the number of leaves and splits without actually building the whole tree.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="scratch-space"><a class="anchor" href="#scratch-space"></a>Scratch Space</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So what we are going to do here is to allocate a pointer-tree structure into some scratch space, and then copy that into an <code>&amp;'m mut</code> array.
How do we find the scratch space?
Our memory is <code>&amp;'m [u8]</code>.
We allocate stuff from the start of the region.
So we can split of some amount of scratch space from the end:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="o">&amp;</span><span class="nv">'s</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">])</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Stuff we allocate into the first half is allocated "permanently".
Stuff we allocate into the second half is allocated temporarily.
When we drop temp buffer, we can reclaim all that space.</p>
</div>
<div class="paragraph">
<p>This&#8230;&#8203; probably is the most sketchy part of the whole endeavor.
It is <code>unsafe</code>, requires lifetimes casing, and I actually can&#8217;t get it past miri.
But it should be fine, right?</p>
</div>
<div class="paragraph">
<p>So, I have the following thing API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="n">with_scratch</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>It can be used like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_scratch</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">mem</span> <span class="o">=</span> <span class="nn">Mem</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">mem</span><span class="nf">.alloc</span><span class="p">(</span><span class="mi">0u8</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mem</span><span class="nf">.with_scratch</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">|</span><span class="n">mem</span><span class="p">,</span> <span class="n">scratch</span><span class="p">|</span> <span class="p">{</span>
    <span class="c1">// Here, we can allocate _permanent_ stuff from `mem`,</span>
    <span class="c1">// and temporary stuff from `scratch`.</span>
    <span class="c1">// Only permanent stuff can escape.</span>

    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mem</span><span class="nf">.alloc</span><span class="p">(</span><span class="mi">1u8</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">scratch</span><span class="nf">.alloc</span><span class="p">(</span><span class="mi">2u8</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">((</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">z</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>

    <span class="c1">// The rest of memory is occupied by scratch.</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">mem</span><span class="nf">.alloc</span><span class="p">(</span><span class="mi">0u8</span><span class="p">)</span><span class="nf">.is_err</span><span class="p">());</span>

    <span class="n">y</span> <span class="c1">// Returning z here fails.</span>
  <span class="p">});</span>

  <span class="c1">// The scratch memory is now reclaimed.</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">mem</span><span class="nf">.alloc</span><span class="p">(</span><span class="mi">3u8</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
  <span class="nd">assert_eq!</span><span class="p">((</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">z</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
  <span class="c1">// Will fail to compile.</span>
  <span class="c1">// assert_eq!(*x, 0);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And here&#8217;s how <code>with_scratch</code> implemented:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">with_scratch</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
  <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">raw</span> <span class="o">=</span> <span class="nn">mem</span><span class="p">::</span><span class="nf">take</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.raw</span><span class="p">);</span>

  <span class="c1">// Split off scratch space.</span>
  <span class="k">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">raw</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">scratch</span><span class="p">)</span> <span class="o">=</span> <span class="n">raw</span><span class="nf">.split_at_mut</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>

  <span class="k">self</span><span class="py">.raw</span> <span class="o">=</span> <span class="n">mem</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nf">f</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">Mem</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">scratch</span><span class="p">));</span>

  <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>
  <span class="c1">// Glue the scratch space back in.</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
  <span class="c1">// This makes miri unhappy, any suggestions? :(</span>
  <span class="k">self</span><span class="py">.raw</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts_mut</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="p">};</span>
  <span class="n">res</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>With this infrastructure in place, we can finally implement bvh construction!
We&#8217;ll do it in three steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Split of half the memory into a scratch space.</p>
</li>
<li>
<p>Build a dynamically-sized tree in that space, counting leaves and interior nodes.</p>
</li>
<li>
<p>Allocate arrays of the right size in the permanent space, and copy data over once.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Bvh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">splits</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">BvhSplit</span><span class="p">],</span>
  <span class="n">leaves</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">BvhLeaf</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">BvhSplit</span> <span class="p">{</span>
  <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span>
  <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
  <span class="n">axis</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">BvhLeaf</span> <span class="p">{</span>
  <span class="n">face</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Temporary tree we store in the scratch space.</span>
<span class="k">enum</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Split</span> <span class="p">{</span>
    <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="o">&amp;</span><span class="nv">'s</span> <span class="k">mut</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span>
    <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">u8</span>
  <span class="p">},</span>
  <span class="n">Leaf</span> <span class="p">{</span> <span class="n">face</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span> <span class="p">},</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">build</span><span class="p">(</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">mesh</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Mesh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Bvh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">free_mem</span> <span class="o">=</span> <span class="n">mem</span><span class="nf">.free</span><span class="p">();</span>
  <span class="n">mem</span><span class="nf">.with_scratch</span><span class="p">(</span><span class="n">free_mem</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">|</span><span class="n">mem</span><span class="p">,</span> <span class="n">scratch</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">n_splits</span><span class="p">,</span> <span class="n">n_leaves</span><span class="p">)</span> <span class="o">=</span>
      <span class="nf">build_scratch</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="n">mesh</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="n">Bvh</span> <span class="p">{</span>
      <span class="n">splits</span><span class="p">:</span> <span class="n">mem</span><span class="nf">.alloc_array_default</span><span class="p">(</span><span class="n">n_splits</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
      <span class="n">leaves</span><span class="p">:</span> <span class="n">mem</span><span class="nf">.alloc_array_default</span><span class="p">(</span><span class="n">n_leaves</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">copy</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">build_scratch</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">mesh</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Mesh</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'s</span> <span class="k">mut</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">copy</span><span class="o">&lt;</span><span class="nv">'m</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span><span class="p">(</span><span class="n">res</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Bvh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And that&#8217;s it!
The thing actually works, miri complaints notwithstanding!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusions"><a class="anchor" href="#conclusions"></a>Conclusions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Actually, I am impressed.
I was certain that this won&#8217;t actually work out, and that I&#8217;d have to write copious amount of unsafe to get the runtime behavior I want.
Specifically, I believed that <code>&amp;'m mut T&lt;'m&gt;</code> variance issue would force my hand to add <code>'m</code>, <code>'mm</code>, <code>'mmm</code> and further lifetimes, but that didn&#8217;t happen.
For &#8220;owning&#8221; pointers, <code>&amp;'m mut T&lt;'m'&gt;</code> turned out to work fine!
It&#8217;s only when processing you might need extra lifetimes.
<code>Parser&lt;'m, 'i, 'a&gt;</code> is at least two lifetimes more than I am completely comfortable with, but I guess I can live with that.</p>
</div>
<div class="paragraph">
<p>I wonder how far this style of programming can be pushed.
Aesthetically, I quite like that I can tell precisely how much memory the program would use!</p>
</div>
<div class="paragraph">
<p>Code for the post: <a href="http://github.com/matklad/crt" class="bare">http://github.com/matklad/crt</a>.</p>
</div>
<div class="paragraph">
<p>Discussion on <a href="https://old.reddit.com/r/rust/comments/xx7xci/blog_post_hard_mode_rust/">/r/rust</a>.</p>
</div>
</div>
</div>
</article>

  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/_posts/2022-10-06-hard-mode-rust.adoc">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href=" /feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
