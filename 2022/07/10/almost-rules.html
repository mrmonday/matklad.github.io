<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Almost Rules</title>
  <meta name="description"
    content="This is going to be a philosophical post, vaguely about language design, and vaguely about Rust.If you&#8217;ve been following this blog for a while, you kno...">
  <link rel="canonical" href="https://matklad.github.io//2022/07/10/almost-rules.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io//feed.xml">

  <style>
    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Regular.woff2') format('woff2');
    }

    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Bold.woff2') format('woff2');
      ;
      font-weight: bold;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      margin-block-start: 0;
      margin-block-end: 0;
    }

    h1,
    h2,
    h3 {
      font-weight: 300;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    main {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 80ch;
      padding-left: 2ch;
      padding-right: 2ch;
    }

    .site-header {
      width: 100%;
      max-width: 80ch;
      margin-bottom: 1.5rem;
    }

    .site-header>nav {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: baseline;
    }

    .site-header .-title {
      flex-grow: 2;
    }

    .site-footer {
      display: flex;
      justify-content: center;
      align-items: baseline;
      width: 100%;
      max-width: 80ch;
      margin-top: 1rem;
      height: 2rem;
      padding-left: 1ch;
      padding-right: 1ch;
    }
  </style>
  <link rel="stylesheet" href=" /css/adoc.css">
  <link rel="stylesheet" href=" /css/rouge-github.css">
  <link rel="stylesheet" href=" /css/main.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=EB+Garamond:400,400italic,700,700italic%7COpen+Sans:300">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header class="site-header">
    <nav>
      <a class="-title" href="/">matklad</a>
      
      
      <a href="/about/">About</a>
      
      
      
      
      
      <a href="/resume/">Resume</a>
      
      
      
      
      
      
      
      
      
      
    </nav>
  </header>

  <main>
    <article>
  <h1>Almost Rules</h1>
  <div class="post-meta sect1">Jul 10, 2022</div>
  <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is going to be a philosophical post, vaguely about language design, and vaguely about Rust.
If you&#8217;ve been following this blog for a while, you know that one theme I consistently hammer at is that of boundaries.
This article is no exception!</p>
</div>
<div class="paragraph">
<p>Obligatory link to Ted Kaminski:</p>
</div>
<div class="paragraph">
<p><a href="https://www.tedinski.com/2018/02/06/system-boundaries.html" class="bare">https://www.tedinski.com/2018/02/06/system-boundaries.html</a></p>
</div>
<div class="paragraph">
<p>The most important boundary for a software project is its external interface, that which the users directly interact with and which you give backwards compatibility guarantees for.
For a web-service, this would be the URL scheme and the shape of JSON request and responses.
For a command line application&#8201;&#8212;&#8201;the set and the meaning of command-line flags.
For an OS kernel&#8201;&#8212;&#8201;the set of syscalls (Linux) or the blessed user-space libraries (Mac).
And, for a programming language, this would be the definition of the language itself, its syntax and semantics.</p>
</div>
<div class="paragraph">
<p>Sometimes, however, it is beneficial to install somewhat artificial, internal boundaries, a sort-of macro level layers pattern.
Boundaries have a high cost.
They prevent changes.
But a skillfully placed internal (or even an artificial external) boundary can also help.</p>
</div>
<div class="paragraph">
<p>It cuts the system in two, and, if the cut is relatively narrow in comparison to the overall size of the system (hourglass shape), this boundary becomes a great way to understand the system.
Understanding <em>just</em> the boundary allows you to imagine how the subsystem beneath it <em>could</em> be implemented.
Most of the time, your imaginary version would be pretty close to what actually happens, and this mental map would help you a great deal to peel off the layers of glue code and get a gut feeling for where the core logic is.</p>
</div>
<div class="paragraph">
<p>Even if an internal boundary starts out in the right place, it, unlike an external one, is ever in danger of being violated.
&#8220;Internal boundary&#8221; is a very non-physical thing, most of the time it&#8217;s just informal rules like &#8220;module A shall not import module B&#8221;.
It&#8217;s very hard to notice that something is <em>not</em> being done!
That&#8217;s why, I think, larger companies can benefit from microservices architecture: in theory, if we <em>just</em> solve human coordination problem, a monolith can be architectured just as cleanly, while offering much better performance.
In practice, at sufficient scale, maintaining good architecture across teams is hard, and becomes much easier if the intended internal boundaries are reified as processes.</p>
</div>
<div class="paragraph">
<p>It&#8217;s hard enough to protect from accidental breaching of internal boundaries.
But there&#8217;s a bigger problem: often, internal boundaries stand in the way of user-visible system features, and it takes a lot of authority to protect internal system&#8217;s boundary at the cost of not shipping something.</p>
</div>
<div class="paragraph">
<p>In this post, I&#8217;d want to catalog some of the cases I&#8217;ve seen in the Rust programming language where I think an internal boundaries were eroded with time.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="namespaces"><a class="anchor" href="#namespaces"></a>Namespaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s a somewhat obscure feature of Rust&#8217;s name resolution, but various things that inhabit Rust&#8217;s scopes (structs, modules, traits, variables) are split into three namespaces: types, values and macros.
This allows to have two things with the same name in the same scope without causing conflicts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">x</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">fn</span> <span class="nf">x</span><span class="p">()</span> <span class="p">{}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above is legal Rust, because the <code>x</code> struct lives in the types namespace, while the <code>x</code> <em>function</em> lives in the values namespace.
The namespaces are reflected syntactically: <code>.</code> is used to traverse value namespace, while <code>::</code> traverses types.</p>
</div>
<div class="paragraph">
<p>Except that this is <em>almost</em> a rule.
There are some cases where compiler gives up on clear syntax-driven namespacing rules and just does ad-hoc disambiguation.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nb">str</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="nn">str</span><span class="p">::</span><span class="nf">from_utf8</span><span class="p">(</span><span class="s">b"hello"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
  <span class="nn">str</span><span class="p">::</span><span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the <code>str</code> in <code>&amp;str</code> and <code>str::len</code> is the <code>str</code> <em>type</em>, from the type namespace.
The two other <code>str</code>s are the <code>str</code> <em>module</em>.
In other words, the <code>str::len</code> is a method of a <code>str</code> type, while <code>str::from_utf8</code> is a free-standing function in the <code>str</code> module.
Like types, modules inhabit the types namespace, so normally the code here would cause a compilation error.
Compiler (and rust-analyzer) just hacks the primitive types case.</p>
</div>
<div class="paragraph">
<p>Another recently added case is that of const generics.
Previously, the <code>T</code> in <code>foo::&lt;T&gt;()</code> was a syntactically-unambiguous reference to something from the types namespace.
Today, it can refer either to a type or to a value.
This begs the question: is splitting type and value namespaces a good idea?
If we have to disambiguate anyway, perhaps we could have just a single namespace and avoid introducing second lookup syntax?
That is, just <code>use std.collections.HashMap;</code>.</p>
</div>
<div class="paragraph">
<p>I <em>think</em> these namespace aspirations re-enact similar developments from C.
I haven&#8217;t double checked my history here, so take the following with the grain of salt and do your own research before quoting, but I <em>think</em> that C, in the initial versions, used to have very strict syntactic separation between types and values.
That&#8217;s why you are required to write <code>struct</code> when declaring a local variable of struct type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="C"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre>struct foo { int a; };

int main(void) {
  struct foo x;
  return 0;
}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>struct</code> keyword tells the parser that it is parsing a type, and, therefore a declaration.
But then at a latter point typedefs were added, and so the parser was taught to disambiguate types and values via the the lexer hack:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="C"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>struct foo {
  int a;
};
typedef struct foo bar;

int main(void) {
  bar x;
  return 0;
}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="patterns-and-expressions"><a class="anchor" href="#patterns-and-expressions"></a>Patterns and Expressions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Rust has separate grammatical categories for patterns and expressions.
It used to be the case that any utterance can be unambiguously classified, depending solely on the syntactic context, as either an expression or a pattern.
But then a minor exception happened:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">value</span> <span class="p">{</span>
    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">(),</span>
    <span class="n">none</span> <span class="k">=&gt;</span> <span class="p">(),</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Syntactically, <code>None</code> and <code>none</code> are indistinguishable.
But they play quite different roles: <code>None</code> refers to the <code>Option::None</code> constant, while <code>none</code> introduces a fresh binding into the scope.
Swift elegantly disambiguates the two at the syntax level, by requiring a leading <code>.</code> for enum variants.
Rust just hacks this at the name-resolution layer, by defaulting to a new binding unless there&#8217;s a matching constant in the scope.</p>
</div>
<div class="paragraph">
<p>Recently, the scope of the hack was increased greatly: with destructing assignment implemented, an expression can be re-classified as a pattern now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">a</span><span class="p">,</span> <span class="k">mut</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Syntactically, <code>=</code> is a binary expression, so both the left hand side and the right hand side are expressions.
But now the <code>lhs</code> is re-interpreted as a pattern.</p>
</div>
<div class="paragraph">
<p>So perhaps the syntactic boundary between expressions and patterns is a fake one, and we should have used unified expression syntax throughout?</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id=""><a class="anchor" href="#"></a><code>::&lt;&gt;</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>A boundary which stands intact is the class of the grammar.
Rust is still an <code>LL(k)</code> language: it can be parsed using a straightforward single-pass algorithm which doesn&#8217;t require backtracking.
The cost of this boundary is that we have to type <code>.collect::&lt;Vec&lt;_&gt;&gt;()</code> rather than <code>.collect&lt;Vec&lt;_&gt;&gt;()</code> (nowadays, I type just <code>.collect()</code> and use the light-bulb to fill-in the turbofish).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="0-0"><a class="anchor" href="#0-0"></a><code>().0.0</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another recent development is the erosion of the boundary between the lexer and the parser.
Rust has tuple structs, and uses <code>.0</code> cutesy syntax to access numbered field.
This is problematic for nested tuple struct.
They need syntax like <code>foo.1.2</code>, but to the lexer this string looks like three tokens: <code>foo</code>, <code>.</code>, <code>1.2</code>.
That is, <code>1.2</code> is a floating point number, <code>6/5</code>.
So, historically one had to write this expression as <code>foo.1 .2</code>, with a meaningful whitespace.</p>
</div>
<div class="paragraph">
<p>Today, this is hacked in the parser, which takes the <code>1.2</code> token from the lexer, inspects its text and further breaks it up into <code>1</code>, <code>.</code> and <code>2</code> tokens.</p>
</div>
<div class="paragraph">
<p>The last example is quite interesting: in Rust, unlike many programming languages, the separation between the lexer and the parser is not an arbitrary internal boundary, but is actually a part of an external, semver protected API.
Tokens are the input to macros, so macro behavior depends on how exactly the input text is split into tokens.</p>
</div>
<div class="paragraph">
<p>And there&#8217;s a second boundary violation here: in theory, &#8220;token&#8221; as seen by a macro is just its text plus hygiene info.
In practice though, to implement captures in macro by example (<code>$x:expr</code> things), a token could also be a fully-formed fragment of internal compiler&#8217;s AST data structure.
The API is carefully future proofed such that, as soon as the macro looks at such a magic token, it gets decomposed into underlying true tokens, but there are some examples where the internal details leak via changes in observable behavior.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lifetime-parametricity"><a class="anchor" href="#lifetime-parametricity"></a>Lifetime Parametricity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To end this on a more positive note, here&#8217;s one pretty important internal boundary which is holding up pretty well.
In Rust, lifetimes don&#8217;t affect code generation.
In fact, lifetimes are fully stripped from the data which is passed to codegen.
This is pretty important: although the inferred lifetimes are opaque and hard to reason about, you can be sure that, for example, the exact location where a value is dropped is independent from the whims of the borrow checker.</p>
</div>
<hr>
<div class="paragraph">
<p>Conclusion: not really? It seems that we are generally overly-optimistic about internal boundaries, and they seem to crumble under the pressure of feature requests, unless the boundary in question is physically reified (please don&#8217;t take this as an endorsement of microservice architecture for compilers).</p>
</div>
</div>
</div>
</article>

  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/_posts/2022-07-10-almost-rules.adoc">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href=" /feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
