<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Caches In Rust</title>
  <meta name="description"
    content="In this post I&#8217;ll describe how to implement caches in Rust.It is inspired by two recent refactors I landed at nearcore (nearcore#6549, nearcore#6811).B...">
  <link rel="canonical" href="https://matklad.github.io//2022/06/11/caches-in-rust.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io//feed.xml">

  <style>
    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Regular.woff2') format('woff2');
    }

    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Bold.woff2') format('woff2');
      ;
      font-weight: bold;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      margin-block-start: 0;
      margin-block-end: 0;
    }

    h1,
    h2,
    h3 {
      font-weight: 300;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    main {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 80ch;
      padding-left: 2ch;
      padding-right: 2ch;
    }

    .site-header {
      width: 100%;
      max-width: 80ch;
      margin-bottom: 1.5rem;
    }

    .site-header>nav {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: baseline;
    }

    .site-header .-title {
      flex-grow: 2;
    }

    .site-footer {
      display: flex;
      justify-content: center;
      align-items: baseline;
      width: 100%;
      max-width: 80ch;
      margin-top: 1rem;
      height: 2rem;
      padding-left: 1ch;
      padding-right: 1ch;
    }
  </style>
  <link rel="stylesheet" href=" /css/adoc.css">
  <link rel="stylesheet" href=" /css/rouge-github.css">
  <link rel="stylesheet" href=" /css/main.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=EB+Garamond:400,400italic,700,700italic%7COpen+Sans:300">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header class="site-header">
    <nav>
      <a class="-title" href="/">matklad</a>
      
      
      <a href="/about/">About</a>
      
      
      
      
      
      <a href="/resume/">Resume</a>
      
      
      
      
      
      
      
      
      
      
    </nav>
  </header>

  <main>
    <article>
  <h1>Caches In Rust</h1>
  <div class="post-meta sect1">Jun 11, 2022</div>
  <div class="paragraph">
<p>In this post I&#8217;ll describe how to implement caches in Rust.
It is inspired by two recent refactors I landed at nearcore (<a href="https://github.com/near/nearcore/pull/6549">nearcore#6549</a>, <a href="https://github.com/near/nearcore/pull/6811">nearcore#6811</a>).
Based on that experience, it seems that implementing caches wrong is rather easy, and making a mistake there risks &#8220;spilling over&#8221;, and spoiling the overall architecture of the application a bit.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with an imaginary setup with an application with some configuration and a database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
  <span class="n">db</span><span class="p">:</span> <span class="n">Db</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The database is an untyped key-value store:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">Db</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
    <span class="o">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the <code>App</code> encapsulates database and provides typed access to domain-specific <code>Widget</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="nd">#[derive(serde::Serialize,</span> <span class="nd">serde::Deserialize)]</span>
<span class="k">struct</span> <span class="n">Widget</span> <span class="p">{</span>
  <span class="n">title</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.to_be_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.db</span><span class="nf">.load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">widget</span><span class="p">:</span> <span class="n">Widget</span> <span class="o">=</span>
      <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="p">{</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
      <span class="p">})</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, for the sake of argument let&#8217;s assume that database access and subsequent deserialization are costly, and that we want to add a cache of Widgets in front of the database.
Data-oriented thinking would compel us to get rid of deserialization step instead, but we will not pursue that idea this time.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll use a simple <code>HashMap</code> for the cache:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
  <span class="n">db</span><span class="p">:</span> <span class="n">Db</span><span class="p">,</span>
  <span class="n">cache</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And we need to modify <code>get_widget</code> method to return the value from the cache, if there is one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span>
<span class="hll">    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
</span>    <span class="n">id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="hll">  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
</span>
<span class="hll">    <span class="k">if</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">let</span> <span class="n">widget</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
</span><span class="hll">      <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">));</span>
</span>    <span class="p">}</span>

    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.to_be_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.db</span><span class="nf">.load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">widget</span><span class="p">:</span> <span class="n">Widget</span> <span class="o">=</span>
      <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="p">{</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
      <span class="p">})</span><span class="o">?</span><span class="p">;</span>

<span class="hll">    <span class="k">self</span><span class="py">.cache</span><span class="nf">.insert</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">widget</span><span class="p">);</span>
</span><span class="hll">    <span class="k">let</span> <span class="n">widget</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The biggest change is the <code>&amp;mut self</code>.
Even when reading the widget, we need to modify the <code>cache</code>, and the easiest way to get that ability is to require an exclusive reference.</p>
</div>
<div class="paragraph">
<p>I want to argue that this path of least resistance doesn&#8217;t lead to a good place.
There are <em>many</em> problems with methods of the following-shape:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Widget</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>First</em>, such methods conflict with each other.
For example, the following code won&#8217;t work, because we&#8217;ll try to borrow the app exclusively twice.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">app</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">App</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">app</span><span class="nf">.get_widget</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="k">let</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">app</span><span class="nf">.get_widget</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Second</em>, the <code>&amp;mut</code> methods conflict even with <code>&amp;</code> methods.
Naively, it would seem that, as <code>get_widget</code> <em>returns</em> a shared reference, we should be able to call <code>&amp;</code> methods.
So, one can expect something like this to work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">w</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Widget</span> <span class="o">=</span> <span class="n">app</span><span class="nf">.get_widget</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="k">let</span> <span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Color</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">app</span><span class="py">.config.main_color</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alas, it doesn&#8217;t.
Rust borrow checker doesn&#8217;t distinguish between <code>mut</code> and non-<code>mut</code> lifetimes (for a good reason: doing that would be unsound).
So, although <code>w</code> is just <code>&amp;Widget</code>, the lifetime there is the same as on the <code>&amp;mut self</code>, so the app remains mutably borrowed while the widget exists.</p>
</div>
<div class="paragraph">
<p><em>Third</em>, perhaps the most important point, the <code>&amp;mut self</code> becomes viral&#8201;&#8212;&#8201;most of functions in the program begin requiring <code>&amp;mut</code>, and you lose type-system distinction between read-only and read-write operations.
There&#8217;s no distinction between &#8220;this function can only modify the cache&#8221; and &#8220;this function can modify literally everything&#8221;.</p>
</div>
<div class="paragraph">
<p><em>Finally</em>, even implementing <code>get_widget</code> is not pleasant.
Seasoned rustaceans among you might twitch at the needlessly-repeated hashmap lookups.
But trying to get rid of those with the help of the entry-API runs into current borrow checker limitations.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at how we can better tackle this!</p>
</div>
<div class="paragraph">
<p>The general idea for this class of problems is to think what the ownership and borrowing situation <em>should</em> be and try to achieve that, as opposed to merely following suggestions by the compiler.
That is, <em>most</em> of the time just using <code>&amp;mut</code> and <code>&amp;</code> as compiler guides you is a path to success, as, it turns out, majority of the code naturally follows simple aliasing rules.
But there are exceptions, it&#8217;s important to recognize them as such and make use of interior mutability to implement the aliasing structure which makes sense.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with a simplified case.
Suppose that there&#8217;s only one <code>Widget</code> to deal with.
In this case, we&#8217;d want something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="n">cache</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Widget</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.cache</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">widget</span><span class="p">;</span>
    <span class="p">}</span>
<span class="hll">    <span class="k">self</span><span class="py">.cache</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">create_widget</span><span class="p">());</span>
</span>    <span class="k">self</span><span class="py">.cache</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This doesn&#8217;t work as is&#8201;&#8212;&#8201;modifying the <code>cache</code> needs <code>&amp;mut</code> which we&#8217;d very much prefer to avoid.
However, thinking about this pattern, it feels like it <em>should</em> be valid&#8201;&#8212;&#8201;we enforce at runtime that the contents of the <code>cache</code> is never overwritten.
That is, we actually <em>do</em> have exclusive access to cache on the highlighted line at runtime, we just can&#8217;t explain that to the type system.
But we can reach out for <code>unsafe</code> for that.
What&#8217;s more, Rust&#8217;s type system is powerful enough to encapsulate that usage of unsafe into a safe and generally re-usable API.
So let&#8217;s pull <a href="https://docs.rs/once_cell"><code>once_cell</code></a> crate for this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="n">cache</span><span class="p">:</span> <span class="nn">once_cell</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">OnceCell</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Widget</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.cache</span><span class="nf">.get_or_init</span><span class="p">(</span><span class="n">create_widget</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Coming back to the original hash-map example, we can apply the same logic here:
as long as we never overwrite, delete or move values, we can safely return references to them.
This is handled by the <a href="https://docs.rs/elsa"><code>elsa</code></a> crate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
  <span class="n">db</span><span class="p">:</span> <span class="n">Db</span><span class="p">,</span>
  <span class="n">cache</span><span class="p">:</span> <span class="nn">elsa</span><span class="p">::</span><span class="nn">map</span><span class="p">::</span><span class="n">FrozenMap</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.to_be_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.db</span><span class="nf">.load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">widget</span><span class="p">:</span> <span class="n">Widget</span> <span class="o">=</span>
      <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="p">{</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
      <span class="p">})</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">widget</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.insert</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">widget</span><span class="p">));</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The third case is that of a bounded cache.
If you need to evict values, than the above reasoning does not apply.
If the user of a cache gets a <code>&amp;T</code>, and than the corresponding entry is evicted, the reference would dangle.
In this situations, we want the clients of the cache to co-own the value.
This is easily handled by an <code>Rc</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
  <span class="n">db</span><span class="p">:</span> <span class="n">Db</span><span class="p">,</span>
  <span class="n">cache</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="nn">lru</span><span class="p">::</span><span class="n">LruCache</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
    <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.borrow_mut</span><span class="p">();</span>
      <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">widget</span><span class="p">)));</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.to_be_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.db</span><span class="nf">.load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">widget</span><span class="p">:</span> <span class="n">Widget</span> <span class="o">=</span>
      <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="p">{</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
      <span class="p">})</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">widget</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">widget</span><span class="p">);</span>
    <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.borrow_mut</span><span class="p">();</span>
      <span class="n">cache</span><span class="nf">.put</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">widget</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To sum up: when implementing a cache, the path of the least resistance is to come up with a signature like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This often leads to problems down the line.
It&#8217;s usually better to employ some interior mutability and get either of these instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span>
<span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an instance of the more general effect: despite the &#8220;mutability&#8221; terminology, Rust references track not mutability, but aliasing.
Mutability and exclusive access are correlated, but not perfectly.
It&#8217;s important to identify instances where you need to employ interior mutability, often they are architecturally interesting.</p>
</div>
<div class="paragraph">
<p>To learn more about relationships between aliasing and mutability, I recommend the following two posts:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Rust: A unique perspective</dt>
<dd>
<p><a href="https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html" class="bare">https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html</a></p>
</dd>
<dt class="hdlist1">Accurate mental model for Rust’s reference types</dt>
<dd>
<p><a href="https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html" class="bare">https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Finally, the &#8220;borrow checker&#8221; limitation is explained (with much skill and humor, I should add), in this document:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Polonius the Crab</dt>
<dd>
<p><a href="https://docs.rs/polonius-the-crab/0.2.1/polonius_the_crab/" class="bare">https://docs.rs/polonius-the-crab/0.2.1/polonius_the_crab/</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>That&#8217;s all! Discussion on <a href="https://old.reddit.com/r/rust/comments/v9xsnb/blog_post_caches_in_rust/">/r/rust</a>.</p>
</div>
</article>

  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/_posts/2022-06-11-caches-in-rust.adoc">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href=" /feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
