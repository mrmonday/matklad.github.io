<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="https://matklad.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://matklad.github.io//" rel="alternate" type="text/html" /><updated>2022-10-06T16:57:26+00:00</updated><id>https://matklad.github.io//feed.xml</id><title type="html">matklad</title><subtitle>Yet another programming blog by Aleksey Kladov aka matklad.
</subtitle><author><name>Aleksey Kladov</name></author><entry><title type="html">Hard Mode Rust</title><link href="https://matklad.github.io//2022/10/06/hard-mode-rust.html" rel="alternate" type="text/html" title="Hard Mode Rust" /><published>2022-10-06T00:00:00+00:00</published><updated>2022-10-06T00:00:00+00:00</updated><id>https://matklad.github.io//2022/10/06/hard-mode-rust</id><content type="html" xml:base="https://matklad.github.io//2022/10/06/hard-mode-rust.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This post is a case study of writing a Rust application using only minimal, artificially constrained API (eg, no dynamic memory allocation).
It assumes a fair bit of familiarity with the language.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hard-mode-rust"><a class="anchor" href="#hard-mode-rust"></a>Hard Mode Rust</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The back story here is a particular criticism of Rust and C&#43;&#43; from hard-core C programmers.
This criticism is aimed at <a href="https://en.cppreference.com/w/cpp/language/raii">RAII</a>&#8201;&#8212;&#8201;the language-defining feature of C&#43;&#43;, which was wholesale imported to Rust as well.
RAII makes using various resources requiring cleanups (file descriptors, memory, locks) easy&#8201;&#8212;&#8201;any place in the program can create a resource, and the cleanup code will be invoked automatically when needed.
And herein lies the problem&#8201;&#8212;&#8201;because allocating resources becomes easy, RAII encourages a sloppy attitude to resources, where they are allocated and destroyed all over the place.
In particular, this leads to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Decrease in reliability. Resources are usually limited in principle, but actual resource exhaustion happens rarely.
If resources are allocated throughout the program, there are many virtually untested codepaths.</p>
</li>
<li>
<p>Lack of predictability. It usually is impossible to predict up-front how much resources will the program consume.
Instead, resource-consumption is observed empirically.</p>
</li>
<li>
<p>Poor performance. Usually, it is significantly more efficient to allocate and free resources in batches.
Cleanup code for individual resources is scattered throughout codebase, increasing code bloat</p>
</li>
<li>
<p>Spaghetti architecture. Resource allocation is an architecturally salient thing.
If all resource management is centralized to a single place, it becomes significantly easier to understand lifecycle of resources.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I think this is a fair criticism.
In fact, I think this is the same criticism that C&#43;&#43; and Rust programmers aim at garbage collected languages.
This is a spectrum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre>           GC object graph
                 v v
                  v
        Tree of values with RAII
                 v v
                  v
Static allocation of resources at startup
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Rust programmers typically are not exposed to the lowest level of this pyramid.
But there&#8217;s a relatively compact exercise to gain the relevant experience: try re-implementing your favorite Rust programs on hard mode.</p>
</div>
<div class="paragraph">
<p><strong>Hard Mode</strong> means that you split your program into <code>std</code> binary and <code>#![no_std]</code> no-alloc library.
Only the small binary is allowed to directly ask OS for resources.
For the library, all resources must be injected.
In particular, to do memory allocation, the library receives a slice of bytes of a fixed size, and should use that for all storage.
Something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="c1">// app/src/main.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">mem_limit</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">memory</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="n">mem_limit</span><span class="p">];</span>
  <span class="nn">app</span><span class="p">::</span><span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">memory</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// app/src/lib.rs</span>
<span class="nd">#![no_std]</span> <span class="c1">// &lt;- the point of the exercise</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">memory</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ray-tracing"><a class="anchor" href="#ray-tracing"></a>Ray Tracing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So, this is what the post is about: my experience implementing a toy hard mode ray tracer.
You can find the code on GitHub: <a href="http://github.com/matklad/crt" class="bare">http://github.com/matklad/crt</a>.</p>
</div>
<div class="paragraph">
<p>The task of a ray tracer is to convert a description of a 3D scene like the following one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="code"><pre>background #000000

camera {
    pos 0,10,-50
    look_at 0,0,0
    up 0,-1,0
    focus 50
    dim 80x60
}

light {
    pos -20,10,0
    color #aa1111
}

plane {
    pos 0,-10,0
    normal 0,1,0
    material {
        color #5566FF
        diffuse 3
    }
}

mesh {
    material {
        color #BB5566
        diffuse 3
    }

    data {
        v 5.92,4.12,0.00
        v 5.83,4.49,0.00
        v 5.94,4.61,0.00
        v 6.17,4.49,0.00
        v 6.42,4.12,0.00
        v 5.38,4.12,2.74
        ...

        vn -0.96,-0.25,0.00
        vn -0.96,0.25,0.00
        vn -0.09,0.99,0.00
        vn 0.68,0.73,0.00
        vn 0.87,0.49,0.00
        vn -0.89,-0.25,-0.36
        ...

        f 1/1 2/2 3/3
        f 4/4 5/5 6/6
        ...
    }

}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Into a rendered image like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://user-images.githubusercontent.com/1711539/194287665-05583649-dcb0-4014-82b9-424f945e19a4.png" alt="194287665 05583649 dcb0 4014 82b9 424f945e19a4">
</div>
</div>
<div class="paragraph">
<p>This works rather intuitive conceptually.
First, imagine the above scene, with an infinite fuchsia colored plane and a red Utah teapot hovering above that.
Then, imagine a camera standing at <code>0,10,-50</code> (in cartesian coordinates) and aiming at the origin.
Now, draw an imaginary rectangular 80x60 screen at a focus distance of 50 from the camera along its line of side.
To get a 2D picture, we shoot a ray from the camera through each &#8220;pixel&#8221; on the screen, note which object on the scene is hit (plan, teapot, background), and color the pixel accordingly.
See <a href="https://pbrt.org">PBRT Book</a> if you feel like falling further into this particular rabbit hole (warning: it is very deep) (I apologize for &#8220;little square pixels&#8221; simplification I use throughout the post :-) ).</p>
</div>
<div class="paragraph">
<p>I won&#8217;t focus on specific algorithms to implement that (indeed, crt is a very naive tracer), but rather highlight Hard Mode Rust specific concerns.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pixel-buffer"><a class="anchor" href="#pixel-buffer"></a>Pixel Buffer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ultimately, the out of a ray tracer is a 2D buffer with 8bit RGB pixels.
One would typically represent it as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">r</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">u8</span> <span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Buf</span> <span class="p">{</span>
  <span class="n">dim</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">2</span><span class="p">]</span>
  <span class="c1">// invariant: data.len() == dim.0 * dim.1</span>
  <span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="n">Color</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For us, we want someone else (main) to allocate that box of colors for us, so instead we do the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">dim</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Color</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">dim</span><span class="p">:</span> <span class="n">Idx</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Color</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">dim</span><span class="na">.0</span> <span class="o">*</span> <span class="n">dim</span><span class="na">.1</span> <span class="o">==</span> <span class="n">buf</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">);</span>
    <span class="n">Buf</span> <span class="p">{</span> <span class="n">dim</span><span class="p">,</span> <span class="n">buf</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>'m</code> lifetime we use for abstract memory managed elsewhere.
Note how the struct grew an extra lifetime!
This is extra price we have to pay for not relying on RAII to cleanup resources for us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="c1">// Easy Mode</span>
<span class="k">fn</span> <span class="nf">paint</span><span class="p">(</span><span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Buf</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">struct</span> <span class="n">PaintCtx</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">Buf</span>
<span class="p">}</span>

<span class="c1">// Hard Mode</span>
<span class="k">fn</span> <span class="nf">paint</span><span class="p">(</span><span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">struct</span> <span class="n">PaintCtx</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note in particular how the <code>Ctx</code> struct now has to include two lifetimes.
This feels unnecessary: <code>'a</code> is shorter than <code>'m</code>.
I wish it was possible to somehow abstract that away:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">PaintCtx</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="c1">// &amp;'a mut exists&lt;'m&gt;: Buf&lt;'m&gt;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>I don&#8217;t think that&#8217;s really possible (<a href="https://matklad.github.io/2018/05/04/encapsulating-lifetime-of-the-field.html">earlier post about this</a>).
In particular, the following would run into variance issues:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">PaintCtx</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ultimately, this is annoying, but not a deal breaker.</p>
</div>
<div class="paragraph">
<p>With this <code>rbg::Buf&lt;'_&gt;</code>, we can sketch the program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre><span class="c1">// hard mode library</span>
<span class="nd">#![no_std]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">render</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">crt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>   <span class="c1">// textual description of the scene</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="c1">// all the memory we can use</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">rgb</span><span class="p">::</span><span class="n">Buf</span><span class="p">,</span> <span class="c1">// write image here</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>

<span class="c1">// main</span>
<span class="nd">#[derive(argh::FromArgs)]</span>
<span class="k">struct</span> <span class="n">Args</span> <span class="p">{</span>
  <span class="nd">#[argh(option,</span> <span class="nd">default</span> <span class="nd">=</span> <span class="s">"64"</span><span class="nd">)]</span>  <span class="n">mem</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="nd">#[argh(option,</span> <span class="nd">default</span> <span class="nd">=</span> <span class="s">"800"</span><span class="nd">)]</span> <span class="n">width</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="nd">#[argh(option,</span> <span class="nd">default</span> <span class="nd">=</span> <span class="s">"600"</span><span class="nd">)]</span> <span class="n">height</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span> <span class="o">=</span> <span class="nn">argh</span><span class="p">::</span><span class="nf">from_env</span><span class="p">();</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">crt</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span>
    <span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">crt</span><span class="p">)</span>
    <span class="nf">.context</span><span class="p">(</span><span class="s">"reading input"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

  <span class="c1">// Allocate all the memory.</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">mem</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">args</span><span class="py">.mem</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">];</span>

  <span class="c1">// Allocate the image</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
    <span class="nn">rgb</span><span class="p">::</span><span class="nn">Color</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="p">(</span><span class="n">args</span><span class="py">.width</span> <span class="o">*</span> <span class="n">args</span><span class="py">.height</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span>
  <span class="p">];</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span>
    <span class="nn">rgb</span><span class="p">::</span><span class="nn">Buf</span><span class="p">::</span><span class="nf">new</span><span class="p">([</span><span class="n">args</span><span class="py">.width</span><span class="p">,</span> <span class="n">args</span><span class="py">.height</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">);</span>

  <span class="nn">render</span><span class="p">::</span><span class="nf">render</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="n">crt</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="n">mem</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">,</span>
  <span class="p">)</span>
  <span class="nf">.map_err</span><span class="p">(|</span><span class="n">err</span><span class="p">|</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nd">format_err!</span><span class="p">(</span><span class="s">"{err}"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

  <span class="c1">// Write result as a PPM image format.</span>
  <span class="nf">write_ppm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">io</span><span class="p">::</span><span class="nf">stdout</span><span class="p">()</span><span class="nf">.lock</span><span class="p">())</span>
    <span class="nf">.context</span><span class="p">(</span><span class="s">"writing output"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">write_ppm</span><span class="p">(</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">rgb</span><span class="p">::</span><span class="n">Buf</span><span class="p">,</span>
  <span class="n">w</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">dyn</span> <span class="nn">io</span><span class="p">::</span><span class="n">Write</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hard-mode-rayon"><a class="anchor" href="#hard-mode-rayon"></a>Hard Mode Rayon</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ray tracing is an embarrassingly parallel task&#8201;&#8212;&#8201;the color of each output pixel can be computed independently.
Usually, the excellent <a href="https://lib.rs/crates/rayon">rayon</a> library is used to take advantage of parallelism, but for our raytracer I want to show a significantly simpler API design for taking advantage of many cores.
I&#8217;ve seen this design in <a href="https://github.com/sorbet/sorbet/blob/master/common/concurrency/WorkerPool.h">Sorbet</a>, a type checker for Ruby.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s how a <code>render</code> function with support for parallelism looks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="hll"><span class="k">type</span> <span class="n">ThreadPool</span><span class="o">&lt;</span><span class="nv">'t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Sync</span><span class="p">))</span> <span class="o">+</span> <span class="nv">'t</span><span class="p">;</span>
</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">render</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">crt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
<span class="hll">  <span class="n">in_parallel</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ThreadPool</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
</span>  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">rgb</span><span class="p">::</span><span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface here is the <code>in_parallel</code> function, which takes another function as an argument and runs it, in parallel, on all available threads.
You typically use it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">work</span><span class="p">:</span> <span class="n">ConcurrentQueue</span><span class="o">&lt;</span><span class="n">Work</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">ConcurrentQueue</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="n">work</span><span class="nf">.extend</span><span class="p">(</span><span class="n">available_work</span><span class="p">);</span>
<span class="nf">in_parallel</span><span class="p">(</span><span class="o">&amp;</span><span class="p">||</span> <span class="p">{</span>
  <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">=</span> <span class="n">work</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">process</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is <em>similar</em> to a typical threadpool, but different.
Similar to a threadpool, there&#8217;s a number of threads (typically one per core) which execute arbitrary jobs.
The first difference is that a typical threadpool sends a job to to a single thread, while in this design the same job is broadcasted to all threads.
The job is <code>Fn + Sync</code> rather than <code>FnOnce + Send</code>.
The second difference is that we <em>block</em> until the job is done on all threads, so we can borrow data from the stack.</p>
</div>
<div class="paragraph">
<p>It&#8217;s on the caller to explicitly implement a concurrent queue to distributed specific work items.
In my implementation, I slice the image in rows</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="k">type</span> <span class="n">ThreadPool</span><span class="o">&lt;</span><span class="nv">'t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Sync</span><span class="p">))</span> <span class="o">+</span> <span class="nv">'t</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">render</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">crt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
  <span class="n">in_parallel</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ThreadPool</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">rgb</span><span class="p">::</span><span class="n">Buf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="c1">// Note: this is not mut, because this is</span>
  <span class="c1">// a concurrent iterator.</span>
  <span class="k">let</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">buf</span><span class="nf">.partition</span><span class="p">();</span>
  <span class="nf">in_parallel</span><span class="p">(</span><span class="o">&amp;</span><span class="p">||</span> <span class="p">{</span>
    <span class="c1">// next_row increments an atomic and</span>
    <span class="c1">// uses the row index to give an `&amp;mut`</span>
    <span class="c1">// into the row's pixels.</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">=</span> <span class="n">rows</span><span class="nf">.next_row</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="n">row</span><span class="py">.y</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nn">rgb</span><span class="p">::</span><span class="n">Color</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="py">.buf</span><span class="p">;</span>
      <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">color</span> <span class="o">=</span> <span class="nn">render</span><span class="p">::</span><span class="nf">render_pixel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scene</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]);</span>
        <span class="n">buf</span><span class="p">[</span><span class="n">x</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="nf">to_rgb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">color</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">});</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In <code>main</code>, we implement a concrete <code>ThreadPool</code> by spawning a thread per core:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="k">let</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">match</span> <span class="n">args</span><span class="py">.jobs</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Threads</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">it</span><span class="p">),</span>
    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nn">Threads</span><span class="p">::</span><span class="nf">with_max_threads</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="nn">render</span><span class="p">::</span><span class="nf">render</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="n">crt</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="n">mem</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="p">|</span><span class="n">f</span><span class="p">|</span> <span class="n">threads</span><span class="nf">.in_parallel</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">,</span>
  <span class="p">)</span>
  <span class="nf">.map_err</span><span class="p">(|</span><span class="n">err</span><span class="p">|</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nd">format_err!</span><span class="p">(</span><span class="s">"{err}"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="allocator"><a class="anchor" href="#allocator"></a>Allocator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The scenes we are going to render are fundamentally dynamically sized.
They can contain arbitrary number of objects.
So we can&#8217;t just statically allocate all the memory up-front.
Instead, there&#8217;s a CLI argument which sets the amount of memory a ray tracer can use, and we should either manage with that, or return an error.
So we do need to write our own allocator.
But we&#8217;ll try very hard to only allocate the memory we actually need, so we won&#8217;t have to implement memory deallocation at all.
So a simple bump allocator would do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">raw</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Oom</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">raw</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Mem</span> <span class="p">{</span> <span class="n">raw</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="n">alloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="n">alloc_array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">mut</span> <span class="n">element</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="n">alloc_array_default</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Default</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.alloc_array</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">|</span><span class="n">_</span><span class="p">|</span> <span class="nn">T</span><span class="p">::</span><span class="nf">default</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can create an allocator from a slice of bytes, and then ask it to allocate values and arrays.
Schematically, <code>alloc</code> looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="c1">// PSEUDOCODE, doesn't handle alignment and is broken.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">alloc</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
  <span class="n">val</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">if</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="p">{</span>
    <span class="c1">// Return error if there isn't enough of memory.</span>
    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">Oom</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Split off size_of::&lt;T&gt; bytes from the start,</span>
  <span class="c1">// doing a little `mem::take` dance to placate</span>
  <span class="c1">// the borrowchecker.</span>
  <span class="k">let</span> <span class="n">res</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">raw</span> <span class="o">=</span> <span class="nn">mem</span><span class="p">::</span><span class="nf">take</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.raw</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">raw</span><span class="p">)</span> <span class="o">=</span> <span class="n">raw</span><span class="nf">.split_at_mut</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.raw</span> <span class="o">=</span> <span class="n">raw</span><span class="p">;</span>
    <span class="n">res</span>
  <span class="p">}</span>

  <span class="c1">// Initialize the value</span>
  <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
  <span class="k">unsafe</span> <span class="p">{</span>
    <span class="nn">ptr</span><span class="p">::</span><span class="nf">write</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To make this fully kosher we need to handle alignment as well, but I cut that bit out for brevity.</p>
</div>
<div class="paragraph">
<p>For allocating arrays, it&#8217;s useful if all-zeros bitpattern is a valid default instance of type, as that allows to skip element-wise initialization.
This condition isn&#8217;t easily expressible in today&#8217;s Rust though, so we require initializing every array member.</p>
</div>
<div class="paragraph">
<p>The result of an allocation is <code>&amp;'m T</code>&#8201;&#8212;&#8201;this is how we spell <code>Box&lt;T&gt;</code> on hard mode.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parsing"><a class="anchor" href="#parsing"></a>Parsing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The scene contains various objects, like spheres and planes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Sphere</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">center</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span> <span class="c1">// v64 is [f64; 3]</span>
  <span class="k">pub</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Plane</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">origin</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">normal</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Usually, we&#8217;d represent a scene as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Scene</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">spheres</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Sphere</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">planes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Plane</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We <em>could</em> implement a resizable array (<code>Vec</code>), but doing that would require us to either leak memory, or to implement proper deallocation logic in our allocator, and add destructors to reliably trigger that.
But destructors is exactly something we are trying to avoid in this exercise.
So our scene will have to look like this instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Scene</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">spheres</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Sphere</span><span class="p">],</span>
  <span class="k">pub</span> <span class="n">planes</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Plane</span><span class="p">],</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And that means we want to know the number of objects we&#8217;ll need upfront.
The way we solve this problem is by doing two-pass parsing.
In the first pass, we just count things, then we allocate them, then we actually parse them into allocated space.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">fn</span> <span class="n">parse</span><span class="o">&lt;</span><span class="nv">'m</span><span class="p">,</span> <span class="nv">'i</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'i</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Scene</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Error</span><span class="o">&lt;</span><span class="nv">'i</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="c1">// Size the allocations.</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">n_spheres</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">n_planes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">input</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">word</span> <span class="p">{</span>
      <span class="s">"sphere"</span> <span class="k">=&gt;</span> <span class="n">n_spheres</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">,</span>
      <span class="s">"plane"</span> <span class="k">=&gt;</span> <span class="n">n_planes</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">,</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(),</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Allocate.</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="n">Scene</span> <span class="p">{</span>
    <span class="n">camera</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
    <span class="n">spheres</span><span class="p">:</span> <span class="n">mem</span><span class="nf">.alloc_array_default</span><span class="p">(</span><span class="n">n_spheres</span><span class="p">)</span><span class="o">?</span>
    <span class="n">planes</span><span class="p">:</span> <span class="n">mem</span><span class="nf">.alloc_array_default</span><span class="p">(</span><span class="n">n_planes</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="c1">// Parse _into_ the allocated scene.</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">Parser</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
  <span class="nf">scene</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">res</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="nf">Ok</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>If an error is encountered during parsing, we want to create a helpful error message.
If the message is fully dynamic, we&#8217;d have to allocate it <em>into</em> <code>'m</code>, but it seems simpler to just re-use bits of input for error message.
Hence, <code>Error&lt;'i&gt;</code> is tied to the input lifetime <code>'i</code>, rather memory lifetime <code>'m</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="nested-objects"><a class="anchor" href="#nested-objects"></a>Nested Objects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One interesting type of object on the scene is a mesh of triangles (for example, the teapot is just a bunch of triangles).
A naive way to represent a bunch of triangles is to use a vector:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Triangle</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">a</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">b</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">c</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Mesh</span> <span class="o">=</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Triangle</span><span class="o">&gt;</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is wasteful: in a mesh, each edge is shared by two triangles.
So a single vertex belongs to a bunch of triangles.
If we store a vector of triangles, we are needlessly duplicating vertex data.
A more compact representation is to store unique vertexes once, and to use indexes for sharing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Mesh</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">vertexes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">v64</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">faces</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">MeshFace</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="c1">// Indexes point into vertexes vector.</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MeshFace</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">u32</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, on hard mode that would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Mesh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">vertexes</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">v64</span><span class="p">],</span>
  <span class="k">pub</span> <span class="n">faces</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">MeshFace</span><span class="p">],</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And a scene contains a bunch of meshes :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Scene</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span>
  <span class="k">pub</span> <span class="n">spheres</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Sphere</span><span class="p">],</span>
  <span class="k">pub</span> <span class="n">planes</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Plane</span><span class="p">],</span>
  <span class="k">pub</span> <span class="n">meshes</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">Mesh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">],</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how, if the structure is recursive, we have &#8220;owned pointers&#8221; of <code>&amp;'m mut T&lt;'m&gt;</code> shape.
Originally I worried that that would cause problem with variance, but it seems to work fine for ownership specifically.
During processing, you still need <code>&amp;'a mut T&lt;'m&gt;</code> though.</p>
</div>
<div class="paragraph">
<p>And that&#8217;s why parsing functions hold an uncomfortable bunch of lifetimes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="n">mesh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="p">,</span> <span class="nv">'i</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="nv">'m</span><span class="p">,</span> <span class="nv">'i</span><span class="p">,</span> <span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">res</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mesh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&lt;</span><span class="nv">'i</span><span class="o">&gt;&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The parser <code>p</code> holds <code>&amp;'i str</code> input and a <code>&amp;'a mut Mem&lt;'m&gt;</code> memory.
It parses input <em>into</em> a <code>&amp;'b mut Mesh&lt;'m&gt;</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bounding-volume-hierarchy"><a class="anchor" href="#bounding-volume-hierarchy"></a>Bounding Volume Hierarchy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With <code>Scene&lt;'m&gt;</code> fully parsed, we can finally get to rendering the picture.
A naive way to do this would be to iterate through each pixel, shooting a ray through it, and then do a nested iterations over every shape, looking for the closest intersection.
That&#8217;s going to be slow!
The teapot model contains about 1k triangles, and we have 640*480 pixels, which gives us 307_200_000 ray-triangle intersection tests, which is quite slow even with multithreading.</p>
</div>
<div class="paragraph">
<p>So we are going to speed this up.
The idea is simple&#8201;&#8212;&#8201;just don&#8217;t intersect a ray with each triangle.
It is possible to quickly discard batches of triangles.
If we have a  batch of triangles, we can draw a 3D box around them as a pre-processing step.
Now if the ray doesn&#8217;t intersect the bounding box, we know that it can&#8217;t intersect any of the triangles.
So we can use one test with a bounding box instead of many tests for each triangle.</p>
</div>
<div class="paragraph">
<p>This is of course one-sided&#8201;&#8212;&#8201;if the ray intersects the box, it might still miss all of the triangles.
But, if we place bounding boxes smartly (small boxes which cover many adjacent triangles), we can hope to skip a lot of work.</p>
</div>
<div class="paragraph">
<p>We won&#8217;t go for really smart ways of doing that, and instead will use a simple divide-and-conquer scheme.
Specifically, we&#8217;ll draw a large box around all triangles we have.
Then, we&#8217;ll note which dimension of the resulting box is the longest.
If, for example, the box is very tall, we&#8217;ll cut it in half horizontally, such that each half contains half of the triangles.
Then, we&#8217;ll recursively subdivide the two halves.</p>
</div>
<div class="paragraph">
<p>In the end, we get a binary tree, where each node contains a bounding box and two children, whose bounding boxes are contained in the parent&#8217;s bounding box.
Leaves contains triangles.
This construction is called a bounding volume hierarchy, bvh.</p>
</div>
<div class="paragraph">
<p>To intersect the ray with bvh, we use a recursive procedure.
Starting at the root node, we descend into children whose bounding boxes are intersected by the ray.
Sometimes we&#8217;ll have to descent into both children, but often enough at least one child&#8217;s bounding box won&#8217;t touch the ray, allowing us to completely skip the subtree.</p>
</div>
<div class="paragraph">
<p>On easy mode Rust, we can code it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">BoundingBox</span> <span class="p">{</span>
  <span class="c1">// Opposite corners of the box.</span>
  <span class="n">lo</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span> <span class="n">hi</span><span class="p">:</span> <span class="n">v64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Bvh</span> <span class="p">{</span>
  <span class="n">root</span><span class="p">:</span> <span class="n">BvhNode</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">BvhNode</span> <span class="p">{</span>
  <span class="n">Split</span> <span class="p">{</span>
    <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
    <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">BvhNode</span><span class="o">&gt;</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span>
    <span class="cd">/// Which of X,Y,Z dimensions was used</span>
    <span class="c1">// to cut the bb in two.</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="n">Leaf</span> <span class="p">{</span>
    <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
    <span class="cd">/// Index of the triangle in a mesh.</span>
    <span class="n">triangle</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>On hard mode, we don&#8217;t really love all those separate boxes, we love arrays!
So what we&#8217;d rather have is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Bvh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">splits</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">BvhSplit</span><span class="p">],</span>
  <span class="n">leaves</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">BvhLeaf</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">BvhSplit</span> <span class="p">{</span>
  <span class="cd">/// Index into either splits or leaves.</span>
  <span class="cd">/// The `tag` is in the highest bit.</span>
  <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span>
  <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
  <span class="n">axis</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">BvhLeaf</span> <span class="p">{</span>
  <span class="n">face</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>So we want to write the following function which recursively constructs a bvh for a mesh:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">build</span><span class="p">(</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">mesh</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Mesh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Bvh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is, unlike the parser, we can&#8217;t cheaply determine the number of leaves and splits without actually building the whole tree.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="scratch-space"><a class="anchor" href="#scratch-space"></a>Scratch Space</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So what we are going to do here is to allocate a pointer-tree structure into some scratch space, and then copy that into an <code>&amp;'m mut</code> array.
How do we find the scratch space?
Our memory is <code>&amp;'m [u8]</code>.
We allocate stuff from the start of the region.
So we can split of some amount of scratch space from the end:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="o">&amp;</span><span class="nv">'s</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">])</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Stuff we allocate into the first half is allocated "permanently".
Stuff we allocate into the second half is allocated temporarily.
When we drop temp buffer, we can reclaim all that space.</p>
</div>
<div class="paragraph">
<p>This&#8230;&#8203; probably is the most sketchy part of the whole endeavor.
It is <code>unsafe</code>, requires lifetimes casing, and I actually can&#8217;t get it past miri.
But it should be fine, right?</p>
</div>
<div class="paragraph">
<p>So, I have the following thing API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="n">with_scratch</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>It can be used like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_scratch</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">mem</span> <span class="o">=</span> <span class="nn">Mem</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">mem</span><span class="nf">.alloc</span><span class="p">(</span><span class="mi">0u8</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mem</span><span class="nf">.with_scratch</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">|</span><span class="n">mem</span><span class="p">,</span> <span class="n">scratch</span><span class="p">|</span> <span class="p">{</span>
    <span class="c1">// Here, we can allocate _permanent_ stuff from `mem`,</span>
    <span class="c1">// and temporary stuff from `scratch`.</span>
    <span class="c1">// Only permanent stuff can escape.</span>

    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mem</span><span class="nf">.alloc</span><span class="p">(</span><span class="mi">1u8</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">scratch</span><span class="nf">.alloc</span><span class="p">(</span><span class="mi">2u8</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">((</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">z</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>

    <span class="c1">// The rest of memory is occupied by scratch.</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">mem</span><span class="nf">.alloc</span><span class="p">(</span><span class="mi">0u8</span><span class="p">)</span><span class="nf">.is_err</span><span class="p">());</span>

    <span class="n">y</span> <span class="c1">// Returning z here fails.</span>
  <span class="p">});</span>

  <span class="c1">// The scratch memory is now reclaimed.</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">mem</span><span class="nf">.alloc</span><span class="p">(</span><span class="mi">3u8</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
  <span class="nd">assert_eq!</span><span class="p">((</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">z</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
  <span class="c1">// Will fail to compile.</span>
  <span class="c1">// assert_eq!(*x, 0);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And here&#8217;s how <code>with_scratch</code> implemented:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">with_scratch</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
  <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">raw</span> <span class="o">=</span> <span class="nn">mem</span><span class="p">::</span><span class="nf">take</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.raw</span><span class="p">);</span>

  <span class="c1">// Split off scratch space.</span>
  <span class="k">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">raw</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">scratch</span><span class="p">)</span> <span class="o">=</span> <span class="n">raw</span><span class="nf">.split_at_mut</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>

  <span class="k">self</span><span class="py">.raw</span> <span class="o">=</span> <span class="n">mem</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nf">f</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">Mem</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">scratch</span><span class="p">));</span>

  <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>
  <span class="c1">// Glue the scratch space back in.</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
  <span class="c1">// This makes miri unhappy, any suggestions? :(</span>
  <span class="k">self</span><span class="py">.raw</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts_mut</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="p">};</span>
  <span class="n">res</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>With this infrastructure in place, we can finally implement bvh construction!
We&#8217;ll do it in three steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Split of half the memory into a scratch space.</p>
</li>
<li>
<p>Build a dynamically-sized tree in that space, counting leaves and interior nodes.</p>
</li>
<li>
<p>Allocate arrays of the right size in the permanent space, and copy data over once.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Bvh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">splits</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">BvhSplit</span><span class="p">],</span>
  <span class="n">leaves</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'m</span> <span class="k">mut</span> <span class="p">[</span><span class="n">BvhLeaf</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">BvhSplit</span> <span class="p">{</span>
  <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span>
  <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
  <span class="n">axis</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">BvhLeaf</span> <span class="p">{</span>
  <span class="n">face</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Temporary tree we store in the scratch space.</span>
<span class="k">enum</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Split</span> <span class="p">{</span>
    <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="o">&amp;</span><span class="nv">'s</span> <span class="k">mut</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span>
    <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">u8</span>
  <span class="p">},</span>
  <span class="n">Leaf</span> <span class="p">{</span> <span class="n">face</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">bb</span><span class="p">:</span> <span class="n">BoundingBox</span> <span class="p">},</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">build</span><span class="p">(</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">mesh</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Mesh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Bvh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">free_mem</span> <span class="o">=</span> <span class="n">mem</span><span class="nf">.free</span><span class="p">();</span>
  <span class="n">mem</span><span class="nf">.with_scratch</span><span class="p">(</span><span class="n">free_mem</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">|</span><span class="n">mem</span><span class="p">,</span> <span class="n">scratch</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">n_splits</span><span class="p">,</span> <span class="n">n_leaves</span><span class="p">)</span> <span class="o">=</span>
      <span class="nf">build_scratch</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="n">mesh</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="n">Bvh</span> <span class="p">{</span>
      <span class="n">splits</span><span class="p">:</span> <span class="n">mem</span><span class="nf">.alloc_array_default</span><span class="p">(</span><span class="n">n_splits</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
      <span class="n">leaves</span><span class="p">:</span> <span class="n">mem</span><span class="nf">.alloc_array_default</span><span class="p">(</span><span class="n">n_leaves</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">copy</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">build_scratch</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">mem</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Mem</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">mesh</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Mesh</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'s</span> <span class="k">mut</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="n">Oom</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">copy</span><span class="o">&lt;</span><span class="nv">'m</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span><span class="p">(</span><span class="n">res</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Bvh</span><span class="o">&lt;</span><span class="nv">'m</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And that&#8217;s it!
The thing actually works, miri complaints notwithstanding!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusions"><a class="anchor" href="#conclusions"></a>Conclusions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Actually, I am impressed.
I was certain that this won&#8217;t actually work out, and that I&#8217;d have to write copious amount of unsafe to get the runtime behavior I want.
Specifically, I believed that <code>&amp;'m mut T&lt;'m&gt;</code> variance issue would force my hand to add <code>'m</code>, <code>'mm</code>, <code>'mmm</code> and further lifetimes, but that didn&#8217;t happen.
For &#8220;owning&#8221; pointers, <code>&amp;'m mut T&lt;'m'&gt;</code> turned out to work fine!
It&#8217;s only when processing you might need extra lifetimes.
<code>Parser&lt;'m, 'i, 'a&gt;</code> is at least two lifetimes more than I am completely comfortable with, but I guess I can live with that.</p>
</div>
<div class="paragraph">
<p>I wonder how far this style of programming can be pushed.
Aesthetically, I quite like that I can tell precisely how much memory the program would use!</p>
</div>
<div class="paragraph">
<p>Code for the post: <a href="http://github.com/matklad/crt" class="bare">http://github.com/matklad/crt</a>.</p>
</div>
<div class="paragraph">
<p>Discussion on <a href="https://old.reddit.com/r/rust/comments/xx7xci/blog_post_hard_mode_rust/">/r/rust</a>.</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[This post is a case study of writing a Rust application using only minimal, artificially constrained API (eg, no dynamic memory allocation). It assumes a fair bit of familiarity with the language.]]></summary></entry><entry><title type="html">From Paxos to BFT</title><link href="https://matklad.github.io//2022/10/03/from-paxos-to-bft.html" rel="alternate" type="text/html" title="From Paxos to BFT" /><published>2022-10-03T00:00:00+00:00</published><updated>2022-10-03T00:00:00+00:00</updated><id>https://matklad.github.io//2022/10/03/from-paxos-to-bft</id><content type="html" xml:base="https://matklad.github.io//2022/10/03/from-paxos-to-bft.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is a sequel to <a href="https://matklad.github.io/2020/11/01/notes-on-paxos.html">Notes on Paxos</a> post.
Similarly, the primarily goal here is for me to understand why the BFT consensus algorithm works in detail.
This might, or might not be useful for other people!
The Paxos article is a prerequisite, best to read that now, and return to this article tomorrow :)</p>
</div>
<div class="paragraph">
<p>Note also that while Paxos was more or less a direct translation of Lamport&#8217;s lecture, this post is a mish-mash oft the original BFT paper by Liskov and Castro, my own thinking, and a cursory glance as <a href="https://lamport.azurewebsites.net/tla/byzpaxos.html">this formalization</a>.
As such, the probability that there are no mistakes here is quite low.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="what-is-bft"><a class="anchor" href="#what-is-bft"></a>What is BFT?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>BFT stands for Byzantine Fault Tolerant consensus.
Similarly to Paxos, we imagine a distributed system of computers communicating over a faulty network which can arbitrary reorder, delay, and drop messages.
And we want computers to agree on some specific choice of value among the set of possibilities, such that any two computers pick the same value.
Unlike Paxos though,  we also assume that computers themselves might be faulty or malicious.
So, we add a new condition to our list of bad things.
Besides reordering, duplication, delaying and dropping, a fake message can be manufactured out of thin air.</p>
</div>
<div class="paragraph">
<p>Of course, if absolutely arbitrary messages can be forged, then no consensus is possible&#8201;&#8212;&#8201;each machine lives in its own solipsistic world which might be completely unlike the world of every other machine.
So there&#8217;s one restriction&#8201;&#8212;&#8201;messages are cryptographically signed by the senders, and it is assumed that it is impossible for a faulty node to impersonate non-faulty one.</p>
</div>
<div class="paragraph">
<p>Can we still achieve consensus?
As long as for each <code>f</code> faulty, malicious nodes, we have at least <code>2f + 1</code> honest ones.</p>
</div>
<div class="paragraph">
<p>Similarly to the Paxos post, we will capture this intuition into a precise mathematical statement about trajectories of state machines.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paxos-revisited"><a class="anchor" href="#paxos-revisited"></a>Paxos Revisited</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Our plan is to start with vanilla Paxos, and then patch it to allow byzantine behavior.
Here&#8217;s what we&#8217;ve arrived at last time:</p>
</div>
<div class="listingblock">
<div class="title">Paxos</div>
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre></td><td class="code"><pre>Sets:
         -- Numbered set of ballots (for example, )
         -- Arbitrary set of values
         -- Finite set of acceptors
    2^ -- Set of quorums

  -- Sets of messages for each of the four subphases
  Msgs1a  {type: {"1a"}, bal: }

  Msgs1b  {type: {"1b"}, bal: , acc: ,
            vote: {bal: , val: }  {null}}

  Msgs2a  {type: {"2a"}, bal: , val: }

  Msgs2b  {type: {"2b"}, bal: , val: , acc: }

Assume:
   q1, q2  : q1  q2  {}

Vars:
  -- Set of all messages sent so far
  msgs  2^(Msgs1a  Msgs1b  Msgs2a  Msgs2b)

  -- Function that maps acceptors to ballot numbers or -1
  -- maxBal ::  -&gt;   {-1}
  maxBal  (  {-1})^

  -- Function that maps acceptors to their last vote
  -- lastVote ::  -&gt; {bal: , val: }  {null}
  lastVote  ({bal: , val: }  {null})^

Send(m)  msgs' = msgs  {m}

Safe(b, v) 
   q  :
  let
    qmsgs   {m  msgs: m.type = "1b"  m.bal = b  m.acc  q}
    qvotes  {m  qmsgs: m.vote  null}
  in
       a  q:  m  qmsgs: m.acc = a
     (  qvotes = {}
         m  qvotes:
             m.vote.val = v
             m1  qvotes: m1.vote.bal &lt;= m.vote.bal)

Phase1a(b) 
    maxBal' = maxBal
   lastVote' = lastVote
   Send({type: "1a", bal: b})

Phase1b(a) 
   m  msgs:
      m.type = "1a"  maxBal(a) &lt; m.bal
     maxBal' =  a1  : if a = a1
                            then m.bal - 1
                            else maxBal(a1)
     lastVote' = lastVote
     Send({type: "1b", bal: m.bal, acc: a, vote: lastVote(a)})

Phase2a(b, v) 
    m  msgs: m.type = "2a"  m.bal = b
   Safe(b, v)
   maxBal' = maxBal
   lastVote' = lastVote
   Send({type: "2a", bal: b, val: v})

Phase2b(a) 
   m  msgs:
      m.type = "2a"  maxBal(a) &lt; m.bal
     maxBal' =  a1  : if a = a1 then m.bal else maxBal(a1)
     lastVote' =  a1  : if a = a1
                              then {bal: m.bal, val: m.val}
                              else lastVote(a1)
     Send({type: "2b", bal: m.bal, val: m.val, acc: a})

Init 
    msgs = {}
   maxBal   =  a  : -1
   lastVote =  a  : null

Next 
     b  :
        Phase1a(b)   v  : Phase2a(b, v)
    a  :
        Phase1b(a)  Phase2b(a)

chosen 
  {v  V:  q  , b  : AllVotedFor(q, b, v)}

AllVotedFor(q, b, v) 
   a  q: (a, b, v)  votes

votes 
  let
    msgs2b  {m  msgs: m.type = "2b"}
  in
    {(m.acc, m.bal, m.val): m  msgs2b}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Our general idea is to add some &#8220;evil&#8221; acceptors  to the mix and allow them sending arbitrary messages, while at the same time making sure that the subset of &#8220;good&#8221; acceptors continues to run Paxos.
What makes this complex is that we don&#8217;t know which acceptor are good and which are bad.
So this is our setup</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>Sets:
         -- Numbered set of ballots (for example, )
         -- Arbitrary set of values
         -- Finite set of good acceptors
         -- Finite set of evil acceptors
       -- All acceptors
    2^ -- Set of quorums

  Msgs1a  {type: {"1a"}, bal: }

  Msgs1b  {type: {"1b"}, bal: , acc: ,
            vote: {bal: , val: }  {null}}

  Msgs2a  {type: {"2a"}, bal: , val: }

  Msgs2b  {type: {"2b"}, bal: , val: , acc: }

Assume:
     = {}
   q1, q2  : q1  q2    {}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>If previously the quorum condition was &#8220;any two quorums have an acceptor in common&#8221;, it is now &#8220;any two quorums have a good acceptor in common&#8221;.
An alternative way to say that is &#8220;a byzantine quorum is a super-set of normal quorum&#8221;, which corresponds to the intuition where we are running normal Paxos, and there are just some extra evil guys whom we try to ignore.
For Paxos, we allowed <code>f</code> faulty out of <code>2f + 1</code> total nodes  with <code>f+1</code> quorums.
For Byzantine Paxos, we&#8217;ll have <code>f</code> byzantine out <code>3f + 1</code> nodes with <code>2f+1</code> quorums.
As I&#8217;ve said, if we forget about byzantine folks, we get exactly <code>f + 1</code> out of <code>2f + 1</code> picture of normal Paxos.</p>
</div>
<div class="paragraph">
<p>The next step is to determine behavior for byzantine nodes.
They can send any message, as long as they are the author:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>Byzantine(a) 
       b  :             Send({type: "1a", bal: b})
      b  , v  :      Send({type: "2a", bal: b, val: v})
      b1, b2  , v  : Send({type: "1b", bal: b1, acc: a,
                                  vote: {bal: b2, val: v}})
      b  , v  :      Send({type: "2b", bal: b, val: v, acc: a})
   maxBal' = maxBal
   lastVote' = lastVote
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>That is, a byzantine acceptor can send any <code>1a</code> or <code>2a</code> message at any time, while for <code>1b</code> and <code>2b</code> the author should match.</p>
</div>
<div class="paragraph">
<p>What breaks?
The most obvious thing is <code>Phase2b</code>, that is, voting.
In Paxos, as soon as an acceptor receives a <code>2a</code> message, it votes for it.
The correctness of Paxos hinges on the <code>Safe</code> check before we send <code>2a</code> message, but a Byzantine node can send an arbitrary <code>2a</code>.</p>
</div>
<div class="paragraph">
<p>The solution here is natural: rather than blindly trust <code>2a</code> messages, acceptors would themselves double-check the safety condition, and reject the message if it doesn&#8217;t hold:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>Phase2b(a) 
   m  msgs:
      m.type = "2a"  maxBal(a) &lt; m.bal
<span class="hll">     Safe(m.bal, m.val)
</span>     maxBal' =  a1  : if a = a1 then m.bal else maxBal(a1)
     lastVote' =  a1  : if a = a1
                              then {bal: m.bal, val: m.val}
                              else lastVote(a1)
     Send({type: "2b", bal: m.bal, val: m.val, acc: a})
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Implementation wise, this means that, when a coordinator sends a <code>2a</code>, it also wants to include <code>1b</code> messages proving the safety of <code>2a</code>.
But in the spec we can just assume that all messages are broadcasted, for simplicity.
Ideally, for correct modeling you also want to model how each acceptor learns new messages, to make sure that negative reasoning about a certain message <em>not</em> being sent doesn&#8217;t creep in, but we&#8217;ll avoid that here.</p>
</div>
<div class="paragraph">
<p>However, just re-checking safety doesn&#8217;t fully solve the problem.
It might be the case that several values are safe at a particular ballot (indeed, in the first ballot any value is safe), and it is exactly the job of a coordinator / <code>2a</code> message to pick one value to break the tie.
And in our case a byzantine coordinator can send two <code>2a</code> for different valid values.</p>
</div>
<div class="paragraph">
<p>And here we&#8217;ll make the single non-trivial modification to the algorithm.
Like the <code>Safe</code> condition is at the heart of Paxos, the <code>Confirmed</code> condition is the heart here.</p>
</div>
<div class="paragraph">
<p>So basically we expect a good coordinator to send just one <code>2a</code> message, but a bad one can send many.
And we want to somehow distinguish the two cases.
One way to do that is to broadcast ACKs for <code>2a</code> among acceptors.
If I received a <code>2a</code> message, checked that the value therein is safe, and also know that everyone else received this same <code>2a</code> message, I can safely vote for the value.</p>
</div>
<div class="paragraph">
<p>So we introduce a new message type, <code>2ac</code>, which confirms a valid <code>2a</code> message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre>Msgs2ac  {type: {"2ac"}, bal: , val: , acc: }
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Naturally, evil acceptors can confirm whatever:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>Byzantine(a) 
       b  :             Send({type: "1a", bal: b})
      b1, b2  , v  : Send({type: "1b", bal: b1, acc: a,
                                 vote: {bal: b2, val: v}})
      b  , v  :      Send({type: "2a", bal: b, val: v})
<span class="hll">      b  , v  :      Send({type: "2ac", bal: b, val: v, acc: a})
</span>      b  , v  :      Send({type: "2b", bal: b, val: v, acc: a})
   maxBal' = maxBal
   lastVote' = lastVote
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>But, if we get a quorum of confirmations, we can be sure that no other value will be confirmed in a given ballot (each good acceptors confirms at most a single message in a ballot (and we need a bit of state for that as well))</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre>Confirmed(b, v) 
   q  :  a  q: {type: "2ac", bal: b, val: v, acc: a}  msgs
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Putting everything so far together, we get</p>
</div>
<div class="listingblock">
<div class="title">Not Yet BFT Paxos</div>
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
</pre></td><td class="code"><pre>Sets:
            -- Numbered set of ballots (for example, )
            -- Arbitrary set of values
            -- Finite set of acceptors
<span class="hll">            -- Finite set of evil acceptors
</span><span class="hll">       -- Set of all acceptors
</span><span class="hll">    2^   -- Set of quorums
</span>
  Msgs1a  {type: {"1a"}, bal: }

  Msgs1b   {type: {"1b"}, bal: , acc: ,
             vote: {bal: , val: }  {null}}

  Msgs2a   {type: {"2a"}, bal: , val: }
<span class="hll">  Msgs2ac  {type: {"2ac"}, bal: , val: , acc: }
</span>
  Msgs2b   {type: {"2b"}, bal: , val: , acc: }

Assume:
<span class="hll">     = {}
</span><span class="hll">   q1, q2  : q1  q2    {}
</span>
Vars:
  -- Set of all messages sent so far
  msgs  2^(Msgs1a  Msgs1b  Msgs2a  Msgs2ac  Msgs2b)

  -- Function that maps acceptors to ballot numbers or -1
  -- maxBal ::  -&gt;   {-1}
  maxBal  (  {-1})^

  -- Function that maps acceptors to their last vote
  -- lastVote ::  -&gt; {bal: , val: }  {null}
  lastVote  ({bal: , val: }  {null})^

<span class="hll">  -- Function which maps acceptors to values they confirmed as safe
</span><span class="hll">  -- confirm :: (, ) -&gt;   {null}
</span><span class="hll">  confirm  (  {null})^(  )
</span><span class="hll">
</span>Send(m)  msgs' = msgs  {m}

Confirmed(b, v) 
<span class="hll">   q  :  a  q: {type: "2ac", bal: b, val: v, acc: a}  msgs
</span><span class="hll">
</span>Safe(b, v) 
   q  :
  let
    qmsgs   {m  msgs: m.type = "1b"  m.bal = b  m.acc  q}
    qvotes  {m  qmsgs: m.vote  null}
  in
       a  q:  m  qmsgs: m.acc = a
     (  qvotes = {}
         m  qvotes:
             m.vote.val = v
             m1  qvotes: m1.vote.bal &lt;= m.vote.bal)

Byzantine(a) 
<span class="hll">       b  :             Send({type: "1a", bal: b})
</span><span class="hll">      b1, b2  , v  : Send({type: "1b", bal: b1, acc: a,
</span><span class="hll">                                 vote: {bal: b2, val: v}})
</span><span class="hll">      b  , v  :      Send({type: "2a", bal: b, val: v})
</span><span class="hll">      b  , v  :      Send({type: "2ac", bal: b, val: v, acc: a})
</span><span class="hll">      b  , v  :      Send({type: "2b", bal: b, val: v, acc: a})
</span><span class="hll">   maxBal' = maxBal
</span><span class="hll">   lastVote' = lastVote
</span><span class="hll">   confirm' = confirm
</span>
Phase1b(a) 
   m  msgs:
      m.type = "1a"  maxBal(a) &lt; m.bal
     maxBal' =  a1  : if a = a1
                            then m.bal - 1
                            else maxBal(a1)
     lastVote' = lastVote
     confirm' = confirm
     Send({type: "1b", bal: m.bal, acc: a, vote: lastVote(a)})
<span class="hll">
</span><span class="hll">Phase2ac(a) 
</span><span class="hll">   m  msgs:
</span><span class="hll">      m.type = "2a"
</span><span class="hll">     confirm(a, m.bal) = null
</span><span class="hll">     Safe(m.bal, m.val)
</span><span class="hll">     maxBal' = maxBal
</span><span class="hll">     lastVote' = lastVote
</span><span class="hll">     confirm' =  a1  , b1 \in :
</span><span class="hll">                 if a = a1  b1 = m.bal then m.val else confirm(a1, b1)
</span><span class="hll">     Send({type: "2ac", bal: m.bal, val: m.val, acc: a})
</span>
Phase2b(a) 
   b  , v  :
<span class="hll">      Confirmed(b, v)
</span>     maxBal' =  a1  : if a = a1 then m.bal else maxBal(a1)
     lastVote' =  a1  : if a = a1
                              then {bal: m.bal, val: m.val}
                              else lastVote(a1)
     confirm' = confirm
     Send({type: "2b", bal: m.bal, val: m.val, acc: a})

Init 
    msgs = {}
   maxBal   =  a  : -1
   lastVote =  a  : null
   confirm =  a  , b  : null

Next 
     a  :
        Phase1b(a)  Phase2ac(a)  Phase2b(a)
    a  :
        Byzantine(a)

chosen 
  {v  V:  q  , b  : AllVotedFor(q, b, v)}

AllVotedFor(q, b, v) 
   a  q: (a, b, v)  votes

votes 
  let
    msgs2b  {m  msgs: m.type = "2b"}
  in
    {(m.acc, m.bal, m.val): m  msgs2b}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above, I&#8217;ve also removed phases <code>1a</code> and <code>2a</code>, as byzantine acceptors are allowed to send arbitrary messages as well (we&#8217;ll need explicit <code>1a</code>/<code>2a</code> for liveness, but we won&#8217;t discuss that here).</p>
</div>
<div class="paragraph">
<p>The most important conceptual addition is <code>Phase2ac</code>&#8201;&#8212;&#8201;if an acceptor receives a new <code>2a</code> message for some ballot with a safe value, it sends out the confirmation provided that it hadn&#8217;t done that already.
In <code>Phase2b</code> then we can vote for confirmed values: confirmation by a quorum guarantees both that the value is safe at this ballot, and that this is a single value that can be voted for in this ballot (two different values can&#8217;d be confirmed in the same ballot, because quorums have an honest acceptor in common).
This <em>almost</em> works, but there&#8217;s still a problem.
Can you spot it?</p>
</div>
<div class="paragraph">
<p>The problem is in the <code>Safe</code> condition.
Recall that the goal of the <code>Safe</code> condition is to pick a value <code>v</code> for ballot <code>b</code>, such that, if any earlier ballot <code>b1</code> concludes, the value chosen in <code>b1</code> would necessary be <code>v</code>.
The way <code>Safe</code> works for ballot <code>b</code> in normal Paxos is that the coordinator asks a certain quorum to abstain from further voting in ballots earlier than <code>b</code>, collects existing votes, and uses those votes to pick a safe value.
Specifically, it looks at the vote for the highest-numbered ballot in the set, and declares a value from it as safe (it <em>is</em> safe: it was safe at <em>that</em> ballot, and for all future ballots there&#8217;s a quorum which abstained from voting).</p>
</div>
<div class="paragraph">
<p>This procedure puts a lot of trust in that highest vote, which makes it vulnerable.
An evil acceptor can just say that it voted in some high ballot, and force a choice of arbitrary value.
So, we need some independent confirmation that the vote was cast for a safe value.
And we can re-use <code>2ac</code> messages for this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td class="code"><pre>Safe(b, v) 
   q  Q:
  let
    qmsgs   {m  msgs: m.type = "1b"  m.bal = b  m.acc  q}
    qvotes  {m  qmsgs: m.vote  null}
  in
       a  q:  m  qmsgs: m.acc = a
    (  qvotes = {}
         m  qvotes:
             m.vote.val = v
             m1  qvotes: m1.vote.bal &lt;= m.vote.bal
<span class="hll">            Confirmed(m.vote.bal, v))
</span></pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And &#8230;&#8203; that&#8217;s it, really.
Now we can sketch a proof that this thing indeed achieves BFT consensus, because it actually models normal Paxos among non-byzantine acceptors.</p>
</div>
<div class="paragraph">
<p>Phase1a messages of Paxos are modeled by Phase1a messages of BFT Paxos, as they don&#8217;t have any preconditions, the same goes for Phase1b.
Phase2a message of Paxos is emitted when a value becomes confirmed in BFT Paxos.
This is correct modeling, because BFT&#8217;s Safe condition models normal Paxos Safe condition (this &#8230;&#8203; is a bit inexact I think, to make this exact, we want to separate &#8220;this value is safe&#8221; from &#8220;we are voting for this value&#8221; in original Paxos as well).
Finally, Phase2b also displays direct correspondence.</p>
</div>
<div class="paragraph">
<p>As a final pop-quiz, I claim that the <code>Confirmed(m.vote.bal, v)</code> condition in <code>Safe</code> above can be relaxed.
As stated, <code>Confirmed</code> needs a byzantine quorum of confirmations, which guarantees both that the value is safe and that it is the single confirmed value, which is a bit more than we need here.
Do you see what would be enough?</p>
</div>
<div class="paragraph">
<p>The final specification contains this relaxation:</p>
</div>
<div class="listingblock">
<div class="title">BFT Paxos</div>
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
</pre></td><td class="code"><pre>Sets:
            -- Numbered set of ballots (for example, )
            -- Arbitrary set of values
            -- Finite set of acceptors
            -- Finite set of evil acceptors
       -- Set of all acceptors
    2^   -- Set of quorums
    2^  -- Set of weak quorums

  Msgs1a  {type: {"1a"}, bal: }

  Msgs1b   {type: {"1b"}, bal: , acc: ,
             vote: {bal: , val: }  {null}}

  Msgs2a   {type: {"2a"}, bal: , val: }
  Msgs2ac  {type: {"2ac"}, bal: , val: , acc: }

  Msgs2b   {type: {"2b"}, bal: , val: , acc: }

Assume:
     = {}
   q1, q2  : q1  q2    {}
   q  : q    {}

Vars:
  -- Set of all messages sent so far
  msgs  2^(Msgs1a  Msgs1b  Msgs2a  Msgs2ac  Msgs2b)

  -- Function that maps acceptors to ballot numbers or -1
  -- maxBal ::  -&gt;   {-1}
  maxBal  (  {-1})^

  -- Function that maps acceptors to their last vote
  -- lastVote ::  -&gt; {bal: , val: }  {null}
  lastVote  ({bal: , val: }  {null})^

  -- Function which maps acceptors to values they confirmed as safe
  -- confirm :: (, ) -&gt;   {null}
  confirm  (  {null})^(  )

Send(m)  msgs' = msgs  {m}

Safe(b, v) 
   q  :
  let
    qmsgs   {m  msgs: m.type = "1b"  m.bal = b  m.acc  q}
    qvotes  {m  qmsgs: m.vote  null}
  in
       a  q:  m  qmsgs: m.acc = a
     (  qvotes = {}
         m  qvotes:
             m.vote.val = v
             m1  qvotes: m1.vote.bal &lt;= m.vote.bal
            confirmedWeak(m.vote.val, v))

Confirmed(b, v) 
   q  :  a  q: {type: "2ac", bal: b, val: v, acc: a}  msgs

ConfirmedWeak(b, v) 
   q  :  a  q: {type: "2ac", bal: b, val: v, acc: a}  msgs

Byzantine(a) 
       b  :             Send({type: "1a", bal: b})
      b1, b2  , v  : Send({type: "1b", bal: b1, acc: a,
                                 vote: {bal: b2, val: v}})
      b  , v  :      Send({type: "2a", bal: b, val: v})
      b  , v  :      Send({type: "2ac", bal: b, val: v, acc: a})
      b  , v  :      Send({type: "2b", bal: b, val: v, acc: a})
   maxBal' = maxBal
   lastVote' = lastVote
   confirm' = confirm

Phase1b(a) 
   m  msgs:
      m.type = "1a"  maxBal(a) &lt; m.bal
     maxBal' =  a1  : if a = a1
                            then m.bal - 1
                            else maxBal(a1)
     lastVote' = lastVote
     confirm' = confirm
     Send({type: "1b", bal: m.bal, acc: a, vote: lastVote(a)})

Phase2ac(a) 
   m  msgs:
      m.type = "2a"
     confirm(a, m.bal) = null
     Safe(m.bal, m.val)
     maxBal' = maxBal
     lastVote' = lastVote
     confirm' =  a1  , b1 \in :
                 if a = a1  b1 = m.bal then m.val else confirm(a1, b1)
     Send({type: "2ac", bal: m.bal, val: m.val, acc: a})

Phase2b(a) 
   b  , v  :
      confirmed(b, v)
     maxBal' =  a1  : if a = a1 then m.bal else maxBal(a1)
     lastVote' =  a1  : if a = a1
                              then {bal: m.bal, val: m.val}
                              else lastVote(a1)
     confirm' = confirm
     Send({type: "2b", bal: m.bal, val: m.val, acc: a})

Init 
    msgs = {}
   maxBal   =  a  : -1
   lastVote =  a  : null
   confirm =  a  , b  : null

Next 
     b  :
        Phase1a(b)   v  : Phase2a(b, v)
    a  :
        Phase1b(a)  Phase2ac(a)  Phase2b(a)
    a  :
        Byzantine(a)

chosen 
  {v  V:  q  , b  : AllVotedFor(q, b, v)}

AllVotedFor(q, b, v) 
   a  q: (a, b, v)  votes

votes 
  let
    msgs2b  {m  msgs: m.type = "2b"}
  in
    {(m.acc, m.bal, m.val): m  msgs2b}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>TLA+ specs for this post are available here: <a href="https://github.com/matklad/paxosnotes" class="bare">https://github.com/matklad/paxosnotes</a>.</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[This is a sequel to Notes on Paxos post. Similarly, the primarily goal here is for me to understand why the BFT consensus algorithm works in detail. This might, or might not be useful for other people! The Paxos article is a prerequisite, best to read that now, and return to this article tomorrow :)]]></summary></entry><entry><title type="html">Almost Rules</title><link href="https://matklad.github.io//2022/07/10/almost-rules.html" rel="alternate" type="text/html" title="Almost Rules" /><published>2022-07-10T00:00:00+00:00</published><updated>2022-07-10T00:00:00+00:00</updated><id>https://matklad.github.io//2022/07/10/almost-rules</id><content type="html" xml:base="https://matklad.github.io//2022/07/10/almost-rules.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is going to be a philosophical post, vaguely about language design, and vaguely about Rust.
If you&#8217;ve been following this blog for a while, you know that one theme I consistently hammer at is that of boundaries.
This article is no exception!</p>
</div>
<div class="paragraph">
<p>Obligatory link to Ted Kaminski:</p>
</div>
<div class="paragraph">
<p><a href="https://www.tedinski.com/2018/02/06/system-boundaries.html" class="bare">https://www.tedinski.com/2018/02/06/system-boundaries.html</a></p>
</div>
<div class="paragraph">
<p>The most important boundary for a software project is its external interface, that which the users directly interact with and which you give backwards compatibility guarantees for.
For a web-service, this would be the URL scheme and the shape of JSON request and responses.
For a command line application&#8201;&#8212;&#8201;the set and the meaning of command-line flags.
For an OS kernel&#8201;&#8212;&#8201;the set of syscalls (Linux) or the blessed user-space libraries (Mac).
And, for a programming language, this would be the definition of the language itself, its syntax and semantics.</p>
</div>
<div class="paragraph">
<p>Sometimes, however, it is beneficial to install somewhat artificial, internal boundaries, a sort-of macro level layers pattern.
Boundaries have a high cost.
They prevent changes.
But a skillfully placed internal (or even an artificial external) boundary can also help.</p>
</div>
<div class="paragraph">
<p>It cuts the system in two, and, if the cut is relatively narrow in comparison to the overall size of the system (hourglass shape), this boundary becomes a great way to understand the system.
Understanding <em>just</em> the boundary allows you to imagine how the subsystem beneath it <em>could</em> be implemented.
Most of the time, your imaginary version would be pretty close to what actually happens, and this mental map would help you a great deal to peel off the layers of glue code and get a gut feeling for where the core logic is.</p>
</div>
<div class="paragraph">
<p>Even if an internal boundary starts out in the right place, it, unlike an external one, is ever in danger of being violated.
&#8220;Internal boundary&#8221; is a very non-physical thing, most of the time it&#8217;s just informal rules like &#8220;module A shall not import module B&#8221;.
It&#8217;s very hard to notice that something is <em>not</em> being done!
That&#8217;s why, I think, larger companies can benefit from microservices architecture: in theory, if we <em>just</em> solve human coordination problem, a monolith can be architectured just as cleanly, while offering much better performance.
In practice, at sufficient scale, maintaining good architecture across teams is hard, and becomes much easier if the intended internal boundaries are reified as processes.</p>
</div>
<div class="paragraph">
<p>It&#8217;s hard enough to protect from accidental breaching of internal boundaries.
But there&#8217;s a bigger problem: often, internal boundaries stand in the way of user-visible system features, and it takes a lot of authority to protect internal system&#8217;s boundary at the cost of not shipping something.</p>
</div>
<div class="paragraph">
<p>In this post, I&#8217;d want to catalog some of the cases I&#8217;ve seen in the Rust programming language where I think an internal boundaries were eroded with time.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="namespaces"><a class="anchor" href="#namespaces"></a>Namespaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s a somewhat obscure feature of Rust&#8217;s name resolution, but various things that inhabit Rust&#8217;s scopes (structs, modules, traits, variables) are split into three namespaces: types, values and macros.
This allows to have two things with the same name in the same scope without causing conflicts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">x</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">fn</span> <span class="nf">x</span><span class="p">()</span> <span class="p">{}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above is legal Rust, because the <code>x</code> struct lives in the types namespace, while the <code>x</code> <em>function</em> lives in the values namespace.
The namespaces are reflected syntactically: <code>.</code> is used to traverse value namespace, while <code>::</code> traverses types.</p>
</div>
<div class="paragraph">
<p>Except that this is <em>almost</em> a rule.
There are some cases where compiler gives up on clear syntax-driven namespacing rules and just does ad-hoc disambiguation.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nb">str</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="nn">str</span><span class="p">::</span><span class="nf">from_utf8</span><span class="p">(</span><span class="s">b"hello"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
  <span class="nn">str</span><span class="p">::</span><span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the <code>str</code> in <code>&amp;str</code> and <code>str::len</code> is the <code>str</code> <em>type</em>, from the type namespace.
The two other <code>str</code>s are the <code>str</code> <em>module</em>.
In other words, the <code>str::len</code> is a method of a <code>str</code> type, while <code>str::from_utf8</code> is a free-standing function in the <code>str</code> module.
Like types, modules inhabit the types namespace, so normally the code here would cause a compilation error.
Compiler (and rust-analyzer) just hacks the primitive types case.</p>
</div>
<div class="paragraph">
<p>Another recently added case is that of const generics.
Previously, the <code>T</code> in <code>foo::&lt;T&gt;()</code> was a syntactically-unambiguous reference to something from the types namespace.
Today, it can refer either to a type or to a value.
This begs the question: is splitting type and value namespaces a good idea?
If we have to disambiguate anyway, perhaps we could have just a single namespace and avoid introducing second lookup syntax?
That is, just <code>use std.collections.HashMap;</code>.</p>
</div>
<div class="paragraph">
<p>I <em>think</em> these namespace aspirations re-enact similar developments from C.
I haven&#8217;t double checked my history here, so take the following with the grain of salt and do your own research before quoting, but I <em>think</em> that C, in the initial versions, used to have very strict syntactic separation between types and values.
That&#8217;s why you are required to write <code>struct</code> when declaring a local variable of struct type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="C"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre>struct foo { int a; };

int main(void) {
  struct foo x;
  return 0;
}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>struct</code> keyword tells the parser that it is parsing a type, and, therefore a declaration.
But then at a latter point typedefs were added, and so the parser was taught to disambiguate types and values via the the lexer hack:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="C"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>struct foo {
  int a;
};
typedef struct foo bar;

int main(void) {
  bar x;
  return 0;
}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="patterns-and-expressions"><a class="anchor" href="#patterns-and-expressions"></a>Patterns and Expressions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Rust has separate grammatical categories for patterns and expressions.
It used to be the case that any utterance can be unambiguously classified, depending solely on the syntactic context, as either an expression or a pattern.
But then a minor exception happened:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">value</span> <span class="p">{</span>
    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">(),</span>
    <span class="n">none</span> <span class="k">=&gt;</span> <span class="p">(),</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Syntactically, <code>None</code> and <code>none</code> are indistinguishable.
But they play quite different roles: <code>None</code> refers to the <code>Option::None</code> constant, while <code>none</code> introduces a fresh binding into the scope.
Swift elegantly disambiguates the two at the syntax level, by requiring a leading <code>.</code> for enum variants.
Rust just hacks this at the name-resolution layer, by defaulting to a new binding unless there&#8217;s a matching constant in the scope.</p>
</div>
<div class="paragraph">
<p>Recently, the scope of the hack was increased greatly: with destructing assignment implemented, an expression can be re-classified as a pattern now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">a</span><span class="p">,</span> <span class="k">mut</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Syntactically, <code>=</code> is a binary expression, so both the left hand side and the right hand side are expressions.
But now the <code>lhs</code> is re-interpreted as a pattern.</p>
</div>
<div class="paragraph">
<p>So perhaps the syntactic boundary between expressions and patterns is a fake one, and we should have used unified expression syntax throughout?</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id=""><a class="anchor" href="#"></a><code>::&lt;&gt;</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>A boundary which stands intact is the class of the grammar.
Rust is still an <code>LL(k)</code> language: it can be parsed using a straightforward single-pass algorithm which doesn&#8217;t require backtracking.
The cost of this boundary is that we have to type <code>.collect::&lt;Vec&lt;_&gt;&gt;()</code> rather than <code>.collect&lt;Vec&lt;_&gt;&gt;()</code> (nowadays, I type just <code>.collect()</code> and use the light-bulb to fill-in the turbofish).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="0-0"><a class="anchor" href="#0-0"></a><code>().0.0</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another recent development is the erosion of the boundary between the lexer and the parser.
Rust has tuple structs, and uses <code>.0</code> cutesy syntax to access numbered field.
This is problematic for nested tuple struct.
They need syntax like <code>foo.1.2</code>, but to the lexer this string looks like three tokens: <code>foo</code>, <code>.</code>, <code>1.2</code>.
That is, <code>1.2</code> is a floating point number, <code>6/5</code>.
So, historically one had to write this expression as <code>foo.1 .2</code>, with a meaningful whitespace.</p>
</div>
<div class="paragraph">
<p>Today, this is hacked in the parser, which takes the <code>1.2</code> token from the lexer, inspects its text and further breaks it up into <code>1</code>, <code>.</code> and <code>2</code> tokens.</p>
</div>
<div class="paragraph">
<p>The last example is quite interesting: in Rust, unlike many programming languages, the separation between the lexer and the parser is not an arbitrary internal boundary, but is actually a part of an external, semver protected API.
Tokens are the input to macros, so macro behavior depends on how exactly the input text is split into tokens.</p>
</div>
<div class="paragraph">
<p>And there&#8217;s a second boundary violation here: in theory, &#8220;token&#8221; as seen by a macro is just its text plus hygiene info.
In practice though, to implement captures in macro by example (<code>$x:expr</code> things), a token could also be a fully-formed fragment of internal compiler&#8217;s AST data structure.
The API is carefully future proofed such that, as soon as the macro looks at such a magic token, it gets decomposed into underlying true tokens, but there are some examples where the internal details leak via changes in observable behavior.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lifetime-parametricity"><a class="anchor" href="#lifetime-parametricity"></a>Lifetime Parametricity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To end this on a more positive note, here&#8217;s one pretty important internal boundary which is holding up pretty well.
In Rust, lifetimes don&#8217;t affect code generation.
In fact, lifetimes are fully stripped from the data which is passed to codegen.
This is pretty important: although the inferred lifetimes are opaque and hard to reason about, you can be sure that, for example, the exact location where a value is dropped is independent from the whims of the borrow checker.</p>
</div>
<hr>
<div class="paragraph">
<p>Conclusion: not really? It seems that we are generally overly-optimistic about internal boundaries, and they seem to crumble under the pressure of feature requests, unless the boundary in question is physically reified (please don&#8217;t take this as an endorsement of microservice architecture for compilers).</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[This is going to be a philosophical post, vaguely about language design, and vaguely about Rust. If you&#8217;ve been following this blog for a while, you know that one theme I consistently hammer at is that of boundaries. This article is no exception!]]></summary></entry><entry><title type="html">Unit and Integration Tests</title><link href="https://matklad.github.io//2022/07/04/unit-and-integration-tests.html" rel="alternate" type="text/html" title="Unit and Integration Tests" /><published>2022-07-04T00:00:00+00:00</published><updated>2022-07-04T00:00:00+00:00</updated><id>https://matklad.github.io//2022/07/04/unit-and-integration-tests</id><content type="html" xml:base="https://matklad.github.io//2022/07/04/unit-and-integration-tests.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In this post I argue that integration-vs-unit is a confused, and harmful, distinction.
I provide a more useful two-dimensional mental model instead.
The model is descriptive (it allows to think more clearly about any test), but I also include my personal prescriptions (the model shows metrics which are and aren&#8217;t worth optimizing).</p>
</div>
<div class="paragraph">
<p>Credit for the idea goes to the <a href="https://abseil.io/resources/swe-book">SWE book</a>.
I always felt that integration versus unit debate is confused, the book helped me to formulate in which way exactly.</p>
</div>
<div class="paragraph">
<p>I won&#8217;t actually rigorously demonstrate the existing confusion&#8201;&#8212;&#8201;I find it self-evident.
As just two examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Unit-testing is used as a synonym with automated testing (x-unit frameworks).</p>
</li>
<li>
<p>Cargo uses &#8220;unit&#8221; and &#8220;integration&#8221; terminology to describe Rust-specific properties of the compilation model, which is orthogonal to the traditional, however fuzzy, meaning of this terms.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most of the time, it&#8217;s more productive to speak about just &#8220;tests&#8221;, or maybe &#8220;automated tests&#8221;, rather than argue where something should be considered a unit or an integration tests.</p>
</div>
<div class="paragraph">
<p>But I argue that a useful, more precise classification exists.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="purity"><a class="anchor" href="#purity"></a>Purity</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>The first</em> axis of classification is, broadly speaking, performance.
&#8220;How much time would a thousand of similar tests take?&#8221; is a very useful metric.
The dependency between the time from making an edit to getting the test results and most other interesting metrics in software (performance, time to fix defects, security) is super-linear.
Tests longer than attention span obliterate productivity.</p>
</div>
<div class="paragraph">
<p>It&#8217;s useful to take a closer look at what constitutes a performant test.
One non-trivial observation here is that test speed is categorical, rather than numerical.
Certain tests are order-of-magnitude slower than others.
Consider the following list:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Single-threaded pure computation</p>
</li>
<li>
<p>Multi-threaded parallel computation</p>
</li>
<li>
<p>Multi-threaded concurrent computation with time-based synchronization and access to disk</p>
</li>
<li>
<p>Multi-process computation</p>
</li>
<li>
<p>Distributed computation</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Each step of this ladder adds half-an-order of magnitude to test&#8217;s runtime.</p>
</div>
<div class="paragraph">
<p>Time is not the only thing affected&#8201;&#8212;&#8201;the higher you go, the bigger is the fraction of flaky tests.
It&#8217;s nay impossible to make a test for a pure function flaky.
If you add threads into the mix, keeping flakiness out requires some careful thinking about synchronization.
And if the tests spans several processes, it is almost bound to fail under some more unusual circumstances.</p>
</div>
<div class="paragraph">
<p>Yet another effect we observe along this axis is resilience to unrelated changes.
The more of operating system and other processes is involved in the test, the higher is the probability that some upgrade somewhere breaks something.</p>
</div>
<div class="paragraph">
<p>I think the &#8220;purity&#8221; concept from functional programming is a good way to generalize this axis of the differences between the tests.
Pure test do little-to-no IO, they are independent of timings and environment.
Less pure tests do more of the impure things.
Purity is correlated with performance, repeatability and stability.
Test purity is non-binary, but it is mostly discrete.
Threads, time, file-system, network, processes are the notches to think about.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="extent"><a class="anchor" href="#extent"></a>Extent</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>The second</em> axis is the fraction of the code which gets exercised, potentially indirectly, by the test.
Does the test exercise only the business logic module, or is the database API and the HTTP handling also required?
This is <em>distinct</em> from performance: running more code doesn&#8217;t mean that the code will run slower.
An infinite loop takes very little code.
What affects performance is not whether tests for business logic touch persistence, but whether, in tests, persistence is backed by an in-memory hash-map or by an out-of-process database server.</p>
</div>
<div class="paragraph">
<p>The &#8220;extent&#8221; of the tests is a good indicator of the overall architecture of the application, but usually it isn&#8217;t a worthy metric to optimize by itself.
On the contrary, artificially limiting the extent of tests by mocking your own code (as opposed to mocking impure IO) reduces fidelity of the tests, and makes the code more brittle in the face of refactors.</p>
</div>
<div class="paragraph">
<p>One potential exception here is the impact on compilation time.
In a layered application <code>A &lt; B &lt; C</code>, it&#8217;s possible to test <code>A</code> either through its interface to <code>B</code> (small-extent test) or by driving <code>A</code> indirectly through <code>C</code>.
The latter has a problem that, after changing <code>A</code>, running tests might require, depending on the language, rebuilding <code>B</code> and <code>C</code> as well.</p>
</div>
<hr>
<div class="paragraph">
<p>Summing up:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Don&#8217;t think about tests in terms of opposition between unit and integration, whatever that means. Instead,</p>
</li>
<li>
<p>Think in terms of test&#8217;s <strong>purity</strong> and <strong>extent</strong>.</p>
</li>
<li>
<p><strong>Purity</strong> corresponds to the amount of generalized IO the test is doing and is correlated with desirable metrics, namely performance and resilience.</p>
</li>
<li>
<p><strong>Extent</strong> corresponds to the amount of code the test exercises. Extent somewhat correlates with impurity, but generally does not directly affect performance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And, the prescriptive part:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ruthlessly optimize purity, moving one step down on the ladder of impurity gives huge impact.</p>
</li>
<li>
<p>Generally, just let the tests have their natural extent. Extent isn&#8217;t worth optimizing by itself, but it can tell you something about your application&#8217;s architecture.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you enjoyed this post, you might like <a href="https://matklad.github.io/2021/05/31/how-to-test.html">&#8220;How to Test&#8221;</a> as well.
It goes further in the prescriptive direction, but, when writing it, I didn&#8217;t have the two dimensional purity-extent vocabulary yet.</p>
</div>
<hr>
<div class="paragraph">
<p>As I&#8217;ve said, this framing is lifted from the SWE book.
There are two differences, one small and one big.
The small difference is that the book uses &#8220;size&#8221; terminology in place of &#8220;purity&#8221;.
The big difference is that the second axis is different: rather than looking at which fraction code gets exercised by the test, the book talks about test &#8220;scope&#8221;: how large is the bit we are actually testing?</p>
</div>
<div class="paragraph">
<p>I do find scope concept useful to think about!
And, unlike extent, keeping most tests focused is a good active prescriptive advice.</p>
</div>
<div class="paragraph">
<p>I however find the scope concept a bit too fuzzy for actual classification.</p>
</div>
<div class="paragraph">
<p>Consider this test from rust-analyzer, which checks that we can complete a method from a trait if the trait is implemented:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">completes_trait_method</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">check</span><span class="p">(</span>
        <span class="s">r"
struct S {}
pub trait T {
    fn f(&amp;self)
}
impl T for S {}

fn main(s: S) {
    s.$0
}
"</span><span class="p">,</span>
        <span class="nd">expect!</span><span class="p">[[</span><span class="s">r#"
            me f() (as T) fn(&amp;self)
        "#</span><span class="p">]],</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>I struggle with determining the scope of this test.
On the one hand, this clearly tests very narrow, very specific scenario.
On the other hand, to make this work, all the layers of the system have to work just right.
The lexer, the parser, name resolution and type checking all have to be prepared for incomplete code.
This test tests not so much the completion logic itself, as all the underlying infrastructure for semantic analysis.</p>
</div>
<div class="paragraph">
<p>The test is very easy to classify in the purity/extent framework.
It&#8217;s 100% pure&#8201;&#8212;&#8201;no IO, just a single thread.
It has maximal extent&#8201;&#8212;&#8201;the tests exercises the bulk of the rust-analyzer codebase, the only thing that isn&#8217;t touched here is the LSP itself.</p>
</div>
<div class="paragraph">
<p>Also, as a pitch for the  <a href="https://matklad.github.io/2021/05/31/how-to-test.html">&#8220;How to Test&#8221;</a> post, take a second to appreciate how simple the test is, considering that it tests an error-resilient, highly incremental compiler :)</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[In this post I argue that integration-vs-unit is a confused, and harmful, distinction. I provide a more useful two-dimensional mental model instead. The model is descriptive (it allows to think more clearly about any test), but I also include my personal prescriptions (the model shows metrics which are and aren&#8217;t worth optimizing).]]></summary></entry><entry><title type="html">Notes on GATs</title><link href="https://matklad.github.io//2022/06/29/notes-on-gats.html" rel="alternate" type="text/html" title="Notes on GATs" /><published>2022-06-29T00:00:00+00:00</published><updated>2022-06-29T00:00:00+00:00</updated><id>https://matklad.github.io//2022/06/29/notes-on-gats</id><content type="html" xml:base="https://matklad.github.io//2022/06/29/notes-on-gats.html"><![CDATA[<div class="paragraph">
<p>There&#8217;s a bit of discussion happening in Rust community on the generic associated types topic.
I can not help but add my own thoughts to the pile :-)</p>
</div>
<div class="paragraph">
<p>I don&#8217;t intend to write a well-edited post considering all pros and cones (intentional typo to demonstrate how unedited this is).
Rather, I just want to dump my experience as is.
Ultimately I trust the lang team to make the right call here <strong>way</strong> more than I trust myself.
The post could be read as a bit inflammatory, but my stated goal here is not to sway someone&#8217;s mind by the arguments, but rather expose my own thinking process.</p>
</div>
<div class="paragraph">
<p>This post is partially prompted by the following comment from the RFC:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>I probably have GATs in every project I do write.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>It stuck with me, because this is very much the opposite of the experience I have.
I&#8217;ve been using Rust extensively for a while, mostly as an application (as opposed to library) developer, and I can&#8217;t remember a single instance where I really wanted to have GATs.
This is a consequences of my overall code style&#8201;&#8212;&#8201;I try to use abstraction sparingly and rarely reach out for traits.
I don&#8217;t think I&#8217;ve ever build a meaningful abstraction which was expressed via traits?
On the contrary, I try hard to make everything concrete and non-generic on the language level.</p>
</div>
<div class="paragraph">
<p>What&#8217;s more, when I do reach out for traits, most of the time this is to use trait objects, which give me a new runtime capability to use different, substitutable concrete type.
For the static,monomorphization based subset of traits I find that most of the time non-trait solution seem to work.</p>
</div>
<div class="paragraph">
<p>And I think GATs (and associated types in general) don&#8217;t work with trait objects, which probably explains why, even when I use traits, I don&#8217;t generally need GATs.
Though, it seems to me that lifetime-only subset of GATs actually works with trait objects?
That is, lending iterator seems to be object safe?</p>
</div>
<div class="paragraph">
<p>I guess, the only place where I do, indirectly, want GATs is to make <code>async trait</code> work, but even then, I usually am interested in object-safe async traits, which I think don&#8217;t need and can&#8217;t use GATs?</p>
</div>
<hr>
<div class="paragraph">
<p>Another disconnection between my usage of Rust and discussion surrounding the GATs is in one of the prominent examples&#8201;&#8212;&#8201;parser combinator library.
In practice, for me parser combinator&#8217;s primary use-case was always a vehicle for teaching advanced types (eg, the monads paper uses parsers as one of the examples).
For production use-cases I&#8217;ve encountered, it was always either a hand-written parser, or a full-blown parser generator.</p>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[There&#8217;s a bit of discussion happening in Rust community on the generic associated types topic. I can not help but add my own thoughts to the pile :-)]]></summary></entry><entry><title type="html">Caches In Rust</title><link href="https://matklad.github.io//2022/06/11/caches-in-rust.html" rel="alternate" type="text/html" title="Caches In Rust" /><published>2022-06-11T00:00:00+00:00</published><updated>2022-06-11T00:00:00+00:00</updated><id>https://matklad.github.io//2022/06/11/caches-in-rust</id><content type="html" xml:base="https://matklad.github.io//2022/06/11/caches-in-rust.html"><![CDATA[<div class="paragraph">
<p>In this post I&#8217;ll describe how to implement caches in Rust.
It is inspired by two recent refactors I landed at nearcore (<a href="https://github.com/near/nearcore/pull/6549">nearcore#6549</a>, <a href="https://github.com/near/nearcore/pull/6811">nearcore#6811</a>).
Based on that experience, it seems that implementing caches wrong is rather easy, and making a mistake there risks &#8220;spilling over&#8221;, and spoiling the overall architecture of the application a bit.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with an imaginary setup with an application with some configuration and a database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
  <span class="n">db</span><span class="p">:</span> <span class="n">Db</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The database is an untyped key-value store:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">Db</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
    <span class="o">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the <code>App</code> encapsulates database and provides typed access to domain-specific <code>Widget</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="nd">#[derive(serde::Serialize,</span> <span class="nd">serde::Deserialize)]</span>
<span class="k">struct</span> <span class="n">Widget</span> <span class="p">{</span>
  <span class="n">title</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.to_be_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.db</span><span class="nf">.load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">widget</span><span class="p">:</span> <span class="n">Widget</span> <span class="o">=</span>
      <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="p">{</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
      <span class="p">})</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, for the sake of argument let&#8217;s assume that database access and subsequent deserialization are costly, and that we want to add a cache of Widgets in front of the database.
Data-oriented thinking would compel us to get rid of deserialization step instead, but we will not pursue that idea this time.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll use a simple <code>HashMap</code> for the cache:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
  <span class="n">db</span><span class="p">:</span> <span class="n">Db</span><span class="p">,</span>
  <span class="n">cache</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And we need to modify <code>get_widget</code> method to return the value from the cache, if there is one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span>
<span class="hll">    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
</span>    <span class="n">id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="hll">  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
</span>
<span class="hll">    <span class="k">if</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">let</span> <span class="n">widget</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
</span><span class="hll">      <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">));</span>
</span>    <span class="p">}</span>

    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.to_be_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.db</span><span class="nf">.load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">widget</span><span class="p">:</span> <span class="n">Widget</span> <span class="o">=</span>
      <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="p">{</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
      <span class="p">})</span><span class="o">?</span><span class="p">;</span>

<span class="hll">    <span class="k">self</span><span class="py">.cache</span><span class="nf">.insert</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">widget</span><span class="p">);</span>
</span><span class="hll">    <span class="k">let</span> <span class="n">widget</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The biggest change is the <code>&amp;mut self</code>.
Even when reading the widget, we need to modify the <code>cache</code>, and the easiest way to get that ability is to require an exclusive reference.</p>
</div>
<div class="paragraph">
<p>I want to argue that this path of least resistance doesn&#8217;t lead to a good place.
There are <em>many</em> problems with methods of the following-shape:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Widget</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>First</em>, such methods conflict with each other.
For example, the following code won&#8217;t work, because we&#8217;ll try to borrow the app exclusively twice.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">app</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">App</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">app</span><span class="nf">.get_widget</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="k">let</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">app</span><span class="nf">.get_widget</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Second</em>, the <code>&amp;mut</code> methods conflict even with <code>&amp;</code> methods.
Naively, it would seem that, as <code>get_widget</code> <em>returns</em> a shared reference, we should be able to call <code>&amp;</code> methods.
So, one can expect something like this to work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">w</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Widget</span> <span class="o">=</span> <span class="n">app</span><span class="nf">.get_widget</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="k">let</span> <span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Color</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">app</span><span class="py">.config.main_color</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alas, it doesn&#8217;t.
Rust borrow checker doesn&#8217;t distinguish between <code>mut</code> and non-<code>mut</code> lifetimes (for a good reason: doing that would be unsound).
So, although <code>w</code> is just <code>&amp;Widget</code>, the lifetime there is the same as on the <code>&amp;mut self</code>, so the app remains mutably borrowed while the widget exists.</p>
</div>
<div class="paragraph">
<p><em>Third</em>, perhaps the most important point, the <code>&amp;mut self</code> becomes viral&#8201;&#8212;&#8201;most of functions in the program begin requiring <code>&amp;mut</code>, and you lose type-system distinction between read-only and read-write operations.
There&#8217;s no distinction between &#8220;this function can only modify the cache&#8221; and &#8220;this function can modify literally everything&#8221;.</p>
</div>
<div class="paragraph">
<p><em>Finally</em>, even implementing <code>get_widget</code> is not pleasant.
Seasoned rustaceans among you might twitch at the needlessly-repeated hashmap lookups.
But trying to get rid of those with the help of the entry-API runs into current borrow checker limitations.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at how we can better tackle this!</p>
</div>
<div class="paragraph">
<p>The general idea for this class of problems is to think what the ownership and borrowing situation <em>should</em> be and try to achieve that, as opposed to merely following suggestions by the compiler.
That is, <em>most</em> of the time just using <code>&amp;mut</code> and <code>&amp;</code> as compiler guides you is a path to success, as, it turns out, majority of the code naturally follows simple aliasing rules.
But there are exceptions, it&#8217;s important to recognize them as such and make use of interior mutability to implement the aliasing structure which makes sense.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with a simplified case.
Suppose that there&#8217;s only one <code>Widget</code> to deal with.
In this case, we&#8217;d want something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="n">cache</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Widget</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.cache</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">widget</span><span class="p">;</span>
    <span class="p">}</span>
<span class="hll">    <span class="k">self</span><span class="py">.cache</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">create_widget</span><span class="p">());</span>
</span>    <span class="k">self</span><span class="py">.cache</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This doesn&#8217;t work as is&#8201;&#8212;&#8201;modifying the <code>cache</code> needs <code>&amp;mut</code> which we&#8217;d very much prefer to avoid.
However, thinking about this pattern, it feels like it <em>should</em> be valid&#8201;&#8212;&#8201;we enforce at runtime that the contents of the <code>cache</code> is never overwritten.
That is, we actually <em>do</em> have exclusive access to cache on the highlighted line at runtime, we just can&#8217;t explain that to the type system.
But we can reach out for <code>unsafe</code> for that.
What&#8217;s more, Rust&#8217;s type system is powerful enough to encapsulate that usage of unsafe into a safe and generally re-usable API.
So let&#8217;s pull <a href="https://docs.rs/once_cell"><code>once_cell</code></a> crate for this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="n">cache</span><span class="p">:</span> <span class="nn">once_cell</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">OnceCell</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Widget</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.cache</span><span class="nf">.get_or_init</span><span class="p">(</span><span class="n">create_widget</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Coming back to the original hash-map example, we can apply the same logic here:
as long as we never overwrite, delete or move values, we can safely return references to them.
This is handled by the <a href="https://docs.rs/elsa"><code>elsa</code></a> crate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
  <span class="n">db</span><span class="p">:</span> <span class="n">Db</span><span class="p">,</span>
  <span class="n">cache</span><span class="p">:</span> <span class="nn">elsa</span><span class="p">::</span><span class="nn">map</span><span class="p">::</span><span class="n">FrozenMap</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.to_be_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.db</span><span class="nf">.load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">widget</span><span class="p">:</span> <span class="n">Widget</span> <span class="o">=</span>
      <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="p">{</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
      <span class="p">})</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">widget</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.insert</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">widget</span><span class="p">));</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The third case is that of a bounded cache.
If you need to evict values, than the above reasoning does not apply.
If the user of a cache gets a <code>&amp;T</code>, and than the corresponding entry is evicted, the reference would dangle.
In this situations, we want the clients of the cache to co-own the value.
This is easily handled by an <code>Rc</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
  <span class="n">db</span><span class="p">:</span> <span class="n">Db</span><span class="p">,</span>
  <span class="n">cache</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="nn">lru</span><span class="p">::</span><span class="n">LruCache</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
    <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.borrow_mut</span><span class="p">();</span>
      <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">widget</span><span class="p">)));</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.to_be_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.db</span><span class="nf">.load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">widget</span><span class="p">:</span> <span class="n">Widget</span> <span class="o">=</span>
      <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="p">{</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
      <span class="p">})</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">widget</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">widget</span><span class="p">);</span>
    <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.borrow_mut</span><span class="p">();</span>
      <span class="n">cache</span><span class="nf">.put</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">widget</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To sum up: when implementing a cache, the path of the least resistance is to come up with a signature like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This often leads to problems down the line.
It&#8217;s usually better to employ some interior mutability and get either of these instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span>
<span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an instance of the more general effect: despite the &#8220;mutability&#8221; terminology, Rust references track not mutability, but aliasing.
Mutability and exclusive access are correlated, but not perfectly.
It&#8217;s important to identify instances where you need to employ interior mutability, often they are architecturally interesting.</p>
</div>
<div class="paragraph">
<p>To learn more about relationships between aliasing and mutability, I recommend the following two posts:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Rust: A unique perspective</dt>
<dd>
<p><a href="https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html" class="bare">https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html</a></p>
</dd>
<dt class="hdlist1">Accurate mental model for Rusts reference types</dt>
<dd>
<p><a href="https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html" class="bare">https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Finally, the &#8220;borrow checker&#8221; limitation is explained (with much skill and humor, I should add), in this document:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Polonius the Crab</dt>
<dd>
<p><a href="https://docs.rs/polonius-the-crab/0.2.1/polonius_the_crab/" class="bare">https://docs.rs/polonius-the-crab/0.2.1/polonius_the_crab/</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>That&#8217;s all! Discussion on <a href="https://old.reddit.com/r/rust/comments/v9xsnb/blog_post_caches_in_rust/">/r/rust</a>.</p>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[In this post I&#8217;ll describe how to implement caches in Rust. It is inspired by two recent refactors I landed at nearcore (nearcore#6549, nearcore#6811). Based on that experience, it seems that implementing caches wrong is rather easy, and making a mistake there risks &#8220;spilling over&#8221;, and spoiling the overall architecture of the application a bit.]]></summary></entry><entry><title type="html">Binary Privacy</title><link href="https://matklad.github.io//2022/05/29/binary-privacy.html" rel="alternate" type="text/html" title="Binary Privacy" /><published>2022-05-29T00:00:00+00:00</published><updated>2022-05-29T00:00:00+00:00</updated><id>https://matklad.github.io//2022/05/29/binary-privacy</id><content type="html" xml:base="https://matklad.github.io//2022/05/29/binary-privacy.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This post documents one rule of thumb I find useful when coding:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Either make all fields of a type public, or make none of them public</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Being a rule-of-thumb, it naturally has exceptions, but those are relatively few.
The primary context here is application development.
Libraries with semver-constrained API have other guidelines&#8201;&#8212;&#8201;<a href="https://www.tedinski.com/2018/02/06/system-boundaries.html">the rules are different at the boundaries</a>.</p>
</div>
<div class="paragraph">
<p>This privacy rule is a manifestation of the fact that the two most popular <em>kinds</em> of entities in programs are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Abstract data types&#8201;&#8212;&#8201;complex objects with opaque implementation which guard interior invariants and expose intentionally limited API to the outside world</p>
</li>
<li>
<p>Data&#8201;&#8212;&#8201;relatively simple objects which group a bunch of related attributes together</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If some fields of a type are private, it can&#8217;t be data.
If some fields of a type are public, it can <em>still</em> be an ADT, but the abstraction boundary will be a bit awkward.
Better to just add getters for (usually few) fields which can be public, to make it immediately obvious what role is played by the type.</p>
</div>
<div class="paragraph">
<p>An example of ADT would be <a href="https://github.com/rust-lang/rust-analyzer/blob/f94fa62d69faf5bd63b3772d3ec4f0c76cf2db57/crates/vfs/src/file_set.rs#L14"><code>FileSet</code></a> from rust-analyzer&#8217;s virtual file system implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="nd">#[derive(Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">FileSet</span> <span class="p">{</span>
  <span class="n">files</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">VfsPath</span><span class="p">,</span> <span class="n">FileId</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">paths</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">FileId</span><span class="p">,</span> <span class="n">VfsPath</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FileSet</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">file_id</span><span class="p">:</span> <span class="n">FileId</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">VfsPath</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.files</span><span class="nf">.insert</span><span class="p">(</span><span class="n">path</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">file_id</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.paths</span><span class="nf">.insert</span><span class="p">(</span><span class="n">file_id</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.files</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">file_for_path</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">path</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">VfsPath</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">FileId</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.files</span><span class="nf">.get</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="nf">.copied</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">path_for_file</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">FileId</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">VfsPath</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.paths</span><span class="nf">.get</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">FileId</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'_</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.paths</span><span class="nf">.keys</span><span class="p">()</span><span class="nf">.copied</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This type maintains a bidirectional mapping between string paths and integral file ids.
How exactly the mapping is maintained (hash map, search tree, trie?) is irrelevant, this implementation detail is abstracted away.
Additionally, there&#8217;s an invariant: <code>files</code> and <code>paths</code> fields are consistent, complimentary mappings.
So this is the case where all fields are private and there&#8217;s a bunch of accessor functions.</p>
</div>
<div class="paragraph">
<p>An example of data would be <a href="https://github.com/rust-lang/rust-analyzer/blob/f94fa62d69faf5bd63b3772d3ec4f0c76cf2db57/crates/vfs/src/loader.rs#L26"><code>Directories</code></a> struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Directories</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">extensions</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">include</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AbsPathBuf</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">exclude</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AbsPathBuf</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This type specifies a set of paths to include in VFS, a sort-of simplified gitignore.
This is an inert piece of data&#8201;&#8212;&#8201;a bunch of extensions, include paths and exclude paths.
Any combination of the three is valid, so there&#8217;s no need for privacy here.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="connections"><a class="anchor" href="#connections"></a>Connections</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule is very mechanical, but it reflects a deeper distinction between flavors of types.
For a more thorough treatment of the underlying phenomenon, see &#8220;Be clear what kind of class you&#8217;re writing&#8221; chapter from Alexandrescu&#8217;s &#8220;C++ Coding Standards&#8221; and
<a href="https://www.tedinski.com/2018/02/27/the-expression-problem.html">&#8220;The Expression Problem&#8221;</a> from ever thought-provoking Kaminski.</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[This post documents one rule of thumb I find useful when coding:]]></summary></entry><entry><title type="html">Builder Lite</title><link href="https://matklad.github.io//2022/05/29/builder-lite.html" rel="alternate" type="text/html" title="Builder Lite" /><published>2022-05-29T00:00:00+00:00</published><updated>2022-05-29T00:00:00+00:00</updated><id>https://matklad.github.io//2022/05/29/builder-lite</id><content type="html" xml:base="https://matklad.github.io//2022/05/29/builder-lite.html"><![CDATA[<div class="paragraph">
<p>In this short post, I describe and name a cousin of the builder pattern&#8201;&#8212;&#8201;builder lite.</p>
</div>
<div class="paragraph">
<p>Unlike a traditional builder, which uses a separate builder object, builder lite re-uses the object itself to provide builder functionality.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an illustrative example</p>
</div>
<div class="listingblock">
<div class="title">Builder Lite</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Shape</span> <span class="p">{</span>
  <span class="n">position</span><span class="p">:</span> <span class="n">Vec3</span><span class="p">,</span>
  <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span>
  <span class="n">material</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Material</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Shape</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="n">Shape</span> <span class="p">{</span>
      <span class="n">position</span><span class="p">:</span> <span class="nn">Vec3</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
      <span class="n">geometry</span><span class="p">,</span>
      <span class="n">material</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_position</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="n">Vec3</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.position</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="k">self</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_material</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="n">Material</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.material</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">material</span><span class="p">);</span>
    <span class="k">self</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Call site</span>

<span class="k">let</span> <span class="n">shape</span> <span class="o">=</span> <span class="nn">Shape</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Geometry</span><span class="p">::</span><span class="nn">Sphere</span><span class="p">::</span><span class="nf">with_radius</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
  <span class="nf">.with_position</span><span class="p">(</span><span class="nf">Vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
  <span class="nf">.with_material</span><span class="p">(</span><span class="nn">Material</span><span class="p">::</span><span class="nf">SolidColor</span><span class="p">(</span><span class="nn">Color</span><span class="p">::</span><span class="n">Red</span><span class="p">));</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In contrast, the full builder is significantly wordier at the definition site, and requires a couple of extra invocations at the call site:</p>
</div>
<div class="listingblock">
<div class="title">Builder</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Shape</span> <span class="p">{</span>
  <span class="n">position</span><span class="p">:</span> <span class="n">Vec3</span><span class="p">,</span>
  <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span>
  <span class="n">material</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Material</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">ShapeBuilder</span> <span class="p">{</span>
  <span class="n">position</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Vec3</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">geometry</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">texture</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Shape</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">builder</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">ShapeBuilder</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">ShapeBuilder</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">position</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="n">Vec3</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">geometry</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">material</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="n">Material</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">build</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Shape</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Call site</span>

<span class="k">let</span> <span class="n">shape</span> <span class="o">=</span> <span class="nn">Shape</span><span class="p">::</span><span class="nf">builder</span><span class="p">()</span>
  <span class="nf">.position</span><span class="p">(</span><span class="nf">Vec3</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
  <span class="nf">.geometry</span><span class="p">(</span><span class="nn">Geometry</span><span class="p">::</span><span class="nn">Sphere</span><span class="p">::</span><span class="nf">with_radius</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
  <span class="nf">.material</span><span class="p">(</span><span class="nn">Material</span><span class="p">::</span><span class="nf">SolidColor</span><span class="p">(</span><span class="nn">Color</span><span class="p">::</span><span class="n">Red</span><span class="p">))</span>
  <span class="nf">.build</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The primary benefit of builder-lite is that it is an incremental, zero-cost evolution from the <code>new</code> method.
As such, it is especially useful in the context where the code evolves rapidly, in an uncertain direction.
That is, when building applications rather than library.</p>
</div>
<div class="paragraph">
<p>To pull a motivational example from work, we had the following typical code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">PeerManagerActor</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span>
    <span class="n">store</span><span class="p">:</span> <span class="n">Store</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">NetworkConfig</span><span class="p">,</span>
    <span class="n">client_addr</span><span class="p">:</span> <span class="n">Recipient</span><span class="o">&lt;</span><span class="n">NetworkClientMessages</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">view_client_addr</span><span class="p">:</span> <span class="n">Recipient</span><span class="o">&lt;</span><span class="n">NetworkViewClientMessages</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">routing_table_addr</span><span class="p">:</span> <span class="n">Addr</span><span class="o">&lt;</span><span class="n">RoutingTableActor</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s a <code>new</code> method with a whole bunch of arguments for various dependencies.
What we needed to do is to add yet another dependency, so that it could be overwritten in tests.
The first attempt just added one more parameter to the <code>new</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span>
    <span class="n">store</span><span class="p">:</span> <span class="n">Store</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">NetworkConfig</span><span class="p">,</span>
    <span class="n">client_addr</span><span class="p">:</span> <span class="n">Recipient</span><span class="o">&lt;</span><span class="n">NetworkClientMessages</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">view_client_addr</span><span class="p">:</span> <span class="n">Recipient</span><span class="o">&lt;</span><span class="n">NetworkViewClientMessages</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">routing_table_addr</span><span class="p">:</span> <span class="n">Addr</span><span class="o">&lt;</span><span class="n">RoutingTableActor</span><span class="o">&gt;</span><span class="p">,</span>
<span class="o">+</span>   <span class="n">ping_counter</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">PingCounter</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this change required update of the seven call-sites where the <code>new</code> was called to supply the default counter.
Switching that to builder lite allowed us to only modify a single call-site where we cared to override the counter.</p>
</div>
<div class="paragraph">
<div class="title">A note on naming:</div>
<p>If builder methods are to be used only occasionally, <code>with_foo</code> is the best naming.
If most call-sites make use of builder methods, just <code>.foo</code> might work better.
For boolean properties, sometimes it makes sense to have both:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">fancy</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
  <span class="k">self</span><span class="nf">.with_fancy</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_fancy</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">yes</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
  <span class="k">self</span><span class="py">.fancy</span> <span class="o">=</span> <span class="n">yes</span><span class="p">;</span>
  <span class="k">self</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Discussion on <a href="https://old.reddit.com/r/rust/comments/v07kac/blog_post_builder_lite/">/r/rust</a>.</p>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[In this short post, I describe and name a cousin of the builder pattern&#8201;&#8212;&#8201;builder lite.]]></summary></entry><entry><title type="html">Why LSP?</title><link href="https://matklad.github.io//2022/04/25/why-lsp.html" rel="alternate" type="text/html" title="Why LSP?" /><published>2022-04-25T00:00:00+00:00</published><updated>2022-04-25T00:00:00+00:00</updated><id>https://matklad.github.io//2022/04/25/why-lsp</id><content type="html" xml:base="https://matklad.github.io//2022/04/25/why-lsp.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>LSP (<a href="https://microsoft.github.io/language-server-protocol/">language server protocol</a>) is fairly popular today.
There&#8217;s a standard explanation of why that is the case.
You probably have seen this picture before:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/LSP-MxN.png" alt="LSP MxN">
</div>
</div>
<div class="paragraph">
<p>I believe that this standard explanation of LSP popularity is wrong.
In this post, I suggest an alternative picture.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="standard-explanation"><a class="anchor" href="#standard-explanation"></a>Standard Explanation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The explanation goes like this:</p>
</div>
<div class="paragraph">
<p>There are <code>M</code> editors and <code>N</code> languages.
If you want to support a particular language in a particular editor, you need to write a dedicated plugin for that.
That means <code>M * N</code> work, as the picture on the left vividly demonstrates.
What LSP does is cutting that to <code>M + N</code>, by providing a common thin waist, as show on the right picture.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="why-is-the-explanation-wrong"><a class="anchor" href="#why-is-the-explanation-wrong"></a>Why is the explanation wrong?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The problem with the explanation is that also best to illustrate pictorially.
In short, the picture above is not drawn to scale.
Here&#8217;s a better illustration of how, for example, rust-analyzer + VS Code combo works together:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/ra-code.png" alt="ra code">
</div>
</div>
<div class="paragraph">
<p>The (big) ball on the left is rust-analyzer&#8201;&#8212;&#8201;a language server.
The similarly sized ball on the right is VS Code&#8201;&#8212;&#8201;an editor.
And the small ball in the center is the code to glue them together, <em>including</em> LSP implementations.</p>
</div>
<div class="paragraph">
<p>That code is relatively and absolutely tiny.
The codebases behind either the language server or the editor are enormous.</p>
</div>
<div class="paragraph">
<p>If the standard theory were correct, then, before LSP, we would have lived in a world where some languages has superb IDE support in some editors.
For example, IntelliJ would have been great at Java, Emacs at C++, Vim at C#, etc.
My recollection of that time is quite different.
To get a decent IDE support, you either used a language supported by JetBrains (IntelliJ or ReSharper) or.</p>
</div>
<div class="paragraph">
<p>There was just a single editor providing meaningful semantic IDE support.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="alternative-theory"><a class="anchor" href="#alternative-theory"></a>Alternative Theory</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I would say that the reason for such poor IDE support in the days of yore is different.
Rather than <code>M * N</code> being too big, it was too small, because <code>N</code> was zero and <code>M</code> just slightly more than that.</p>
</div>
<div class="paragraph">
<p>I&#8217;d start with <code>N</code>&#8201;&#8212;&#8201;the number of language servers, this is the side I am relatively familiar with.
Before LSP, there simply weren&#8217;t a lot of working language-server shaped things.
The main reason for that is that building a language server is hard.</p>
</div>
<div class="paragraph">
<p>The essential complexity for a server is pretty high.
It is known that compilers are complicated, and a language server is a compiler <em>and then some</em>.</p>
</div>
<div class="paragraph">
<p><em>First</em>, like a compiler, a language server needs to fully understand the language, it needs to be able to distinguish between valid and invalid programs.
However, while for invalid programs a batch compiler is allowed to emit an error message and exit promptly, a language server must analyze <em>any</em> invalid program as best as it can.
Working with incomplete and invalid programs is the first complication of a language server in comparison to a compiler.</p>
</div>
<div class="paragraph">
<p><em>Second</em>, while a batch compiler is a pure function which transforms source text into machine code, a language server has to work with a code base which is constantly being modified by the user.
It is a compiler with a time dimension, and evolution of state over time is one of the hardest problems in programming.</p>
</div>
<div class="paragraph">
<p><em>Third</em>, a batch compiler is optimized for maximum throughput, while a language server aims to minimize latency (while not completely forgoing throughput).
Adding a latency requirement doesn&#8217;t mean that you need to optimize harder.
Rather, it means that you generally need to turn the architecture on its head to have an acceptable latency at all.</p>
</div>
<div class="paragraph">
<p>And this brings us to a related cluster of accidental complexity surrounding language servers.
It is well understood how to write a batch compiler.
It&#8217;s common knowledge.
While not everyone have read the dragon book (I didn&#8217;t meaningfully get past the parsing chapters), everyone knows that that book contains all the answers.
So most existing compilers end up looking like a typical compiler.
And, when compiler authors start thinking about IDE support, the first thought is &#8220;well, IDE is kinda a compiler, and we have a compiler, so problem solved, right?&#8221;.
This is quite wrong&#8201;&#8212;&#8201;internally an IDE is very different from a compiler but, until very recently, this wasn&#8217;t common knowledge.</p>
</div>
<div class="paragraph">
<p>Language servers are a counter example to the <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/">&#8220;never rewrite&#8221;</a> rule.
Majority of well regarded language servers are rewrites or alternative implementations of batch compilers.</p>
</div>
<div class="paragraph">
<p>Both IntelliJ and Eclipse wrote their own compilers rather than re-using javac inside an IDE.
To provide an adequate IDE support for C#, Microsoft rewrote their C++ batch compiler into an interactive self-hosted one (project Roslyn).
Dart, despite being a from-scratch, relatively modern language, ended up with <em>three</em> implementations (host AOT compiler, host IDE compiler (dart-analyzer), on-device JIT compiler).
Rust tried both&#8201;&#8212;&#8201;incremental evolution of rustc (RLS) and from-scratch implementation (rust-analyzer), and rust-analyzer decisively won.</p>
</div>
<div class="paragraph">
<p>The two exceptions I know are C++ and OCaml.
Curiously, both require forward declarations and header files, and I don&#8217;t think this is a coincidence.
See the <a href="https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html">Three Architectures for a Responsive IDE</a> post for details.</p>
</div>
<div class="paragraph">
<p>To sum up, on the language server&#8217;s side things were in a bad equilibrium.
It was totally possible to implement language servers, but that required a bit of an iconoclastic approach, and it&#8217;s hard to be a pioneering iconoclast.</p>
</div>
<div class="paragraph">
<p>I am less certain what was happening on the editor&#8217;s side.
Still, I do want to claim that we had no editors capable of being an IDE.</p>
</div>
<div class="paragraph">
<p>IDE experience consists of a host of semantic features.
The most notable example is, of course completion.
If one wants to implement custom completion for VS Code, one needs to implement
<a href="https://code.visualstudio.com/api/references/vscode-api#CompletionItemProvider">CompletionItemProvider</a> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="TypeScript"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre>interface CompletionItemProvider {
    provideCompletionItems(
        document: TextDocument,
        position: Position,
    ): CompletionItem[]
}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This means that, in VS Code, code completion (as well as dozens of other IDE related features) is an editor&#8217;s first-class concept, with uniform user UI and developer API.</p>
</div>
<div class="paragraph">
<p>Contrast this with Emacs and Vim.
They just don&#8217;t have proper completion as an editor&#8217;s extension point.
Rather, they expose low-level cursor and screen manipulation API, and then people implement competing completion frameworks on top of that!</p>
</div>
<div class="paragraph">
<p>And that&#8217;s just code completion!
What about parameter info, inlay hints, breadcrumbs, extend selection, assists, symbol search, find usages (I&#8217;ll stop here :) )?</p>
</div>
<div class="paragraph">
<p>To sum the above succinctly, the problem with decent IDE support was not of <code>N * M</code>, but rather of an inadequate equilibrium of a two-sided market.</p>
</div>
<div class="paragraph">
<p>Language vendors were reluctant to create language servers, because it was hard, the demand was low (= no competition from other languages), and, even if one creates a language server, one would find a dozen editors absolutely unprepared to serve as a host for a smart server.</p>
</div>
<div class="paragraph">
<p>On the editor&#8217;s side, there was little incentive for adding high-level APIs needed for IDEs, because there were no potential providers for those APIs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="why-lsp-is-great"><a class="anchor" href="#why-lsp-is-great"></a>Why LSP is great</h2>
<div class="sectionbody">
<div class="paragraph">
<p>And that&#8217;s why I think LSP is great!</p>
</div>
<div class="paragraph">
<p>I don&#8217;t think it was a big technical innovation (it&#8217;s obvious that you want to separate a language-agnostic editor and a language-specific server).
I think it&#8217;s a rather bad (aka, &#8220;good enough&#8221;) technical implementation (stay tuned for &#8220;Why LSP sucks?&#8221; post I guess?).
<em>But</em> it moved us from a world where not having a language IDE was normal and no one was even thinking about language servers, to a world where a language without working completion and goto definition looks unprofessional.</p>
</div>
<div class="paragraph">
<p>Notably, the two-sided market problem was solved by Microsoft, who were a vendor of both languages (C# and TypeScript) and editors (VS Code and Visual Studio), and who were generally losing in the IDE space to a competitor (JetBrains).
While I may rant about particular technical details of LSP, I absolutely admire their strategic vision in this particular area.
They:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>built an editor on web technologies.</p>
</li>
<li>
<p>identified webdev as a big niche where JetBrains struggles (supporting JS in an IDE is next to impossible).</p>
</li>
<li>
<p>built a language (!!!!) to make it feasible to provide IDE support for webdev.</p>
</li>
<li>
<p>built an IDE platform with a very forward-looking architecture (stay tuned for a post where I explain why <code>vscode.d.ts</code> is a marvel of technical excellence).</p>
</li>
<li>
<p>launched LSP to increase the value of their platform in other domains for free (moving the whole world to a significantly better IDE equilibrium as a collateral benefit).</p>
</li>
<li>
<p>and now, with code spaces, are posed to become the dominant player in the &#8220;remote first development&#8221;, should we indeed stop editing, building, and running code on our local machines.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Though, to be fair, I still hope that, in the end, the winner would be JetBrains with their idea of Kotlin as a universal language for any platform :-)
While Microsoft takes full advantage of worse-is-better technologies which are dominant today (TypeScript and Electron), JetBrains tries to fix things from the bottom up (Kotlin and Compose).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="more-on-m-n"><a class="anchor" href="#more-on-m-n"></a>More on M * N</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now I am just going to hammer it in that it&#8217;s <em>really</em> not <code>M * N</code> :)</p>
</div>
<div class="paragraph">
<p><em>First</em>, <code>M * N</code> argument ignores the fact that this is an embarrassingly parallel problem.
Neither language designers need to write plugins for all editors, nor editors need to add special support for all languages.
Rather, a language should implement a server which speaks some protocol, an editor needs to implement language agnostic APIs for providing completions and such, and, if both the language and the editor are not esoteric, someone who is interested in both would just write a bit of glue code to bind the two together!
rust-analyzer&#8217;s VS Code plugin is 3.2k lines of code, neovim plugin is 2.3k and Emacs plugin is 1.2k.
All three are developed independently by different people.
That&#8217;s the magic of decentralized open source development at its finest!
If the plugins were to support custom protocol instead of LSP (provided that the editor supports high-level IDE API inside), I&#8217;d expect to add maybe 2k lines for that, which is still well within hobbyist working part-time budget.</p>
</div>
<div class="paragraph">
<p><em>Second</em>, for <code>M * N</code> optimization you&#8217;d expect the protocol implementation to be generated from some machine readable implementation.
But until the latest release, the source of truth for LSP spec was an informal markdown document.
Every language and client was coming up with their own way to extract protocol out of it, many (including rust-analyzer) were just syncing the changes manually, with quite a bit of dupliction.</p>
</div>
<div class="paragraph">
<p><em>Third</em>, if <code>M * N</code> is a problem, you&#8217;d expect to see only one LSP implementation for each editor.
In reality, there are two competing Emacs implementations (lsp-mode and eglot) and, I kid you not, at the time of writing rust-analyzer&#8217;s manual contains instruction for integration with 6 (six) different LSP clients for vim.
To echo the first point, this is open source!
The <em>total</em> amount of work is almost irrelevant, the thing that matters is the amount of coordination to get things done.</p>
</div>
<div class="paragraph">
<p><em>Fourth</em>, Microsoft itself doesn&#8217;t try to take advantage of <code>M + N</code>.
There&#8217;s <em>no</em> universal LSP implementation in VS Code.
Instead, each language is required to have a dedicated plugin with physically independent implementations of LSP.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="action-items"><a class="anchor" href="#action-items"></a>Action Items</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">Everyone</dt>
<dd>
<p>Please demand better IDE support!
I think today we crossed the threshold of general availability of baseline IDE support, but there&#8217;s so much we can do beyond the basics.
In the ideal world, it should be possible to inspect every little semantic details about expression at the cursor, using the same simple API one can use today to inspect contents of editor&#8217;s buffer.</p>
</dd>
<dt class="hdlist1">Text Editor Authors</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Pay attention to the architecture of VS Code.
While electron delivers questionable user experience, the internal architecture has a lot of wisdom in it.
Do orient editor&#8217;s API around presentation-agnostic high-level features.
Basic IDE functionality should be a first-class extension point, it shouldn&#8217;t be re-invented by every plugin&#8217;s author.
In particular, add <a href="https://rust-analyzer.github.io/blog/2020/09/28/how-to-make-a-light-bulb.html">assist/code action/</a> as a first-class UX concept already.
It&#8217;s the single most important UX innovation of IDEs, which is very old at this point.
Its outright ridiculous that this isn&#8217;t a standard interface across all editors.</p>
</div>
<div class="paragraph">
<p>But don&#8217;t make LSP <em>itself</em> a first class concept.
Surprising as it might seem, VS Code knows <em>nothing</em> about LSP.
It just provides a bunch of extension points without caring the least how they are implemented.
LSP implementation then is just a library, which is used by language-specific plugins.
E.g., Rust and C++ extensions for VS Code do not share the same LSP implementation at runtime, there are two copies of LSP library in memory!</p>
</div>
<div class="paragraph">
<p>Also, try to harness the power of open-source.
Don&#8217;t enforce centralization of all LSP implementations!
Make it possible for separate groups of people to independenty work on perfect Go support and perfect Rust support for your editor.
VS Code is one possible model, with a marketplace and distributed, independent plugins.
But it probably should be possible to organize the work as a single shared repo/source tree, as long as languages can have independent maintainers sets</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Language Server Authors</dt>
<dd>
<p>You are doing a great job!
The quality of IDE support is improving rapidly for all the languages, though I feel this is only a beginning of a long road.
One thing to keep in mind is that LSP is <em>an</em> interface to a semantic info about the language, but it isn&#8217;t <em>the</em> interface.
A better thing might come along.
Even today, limitations of LSP prevent from shipping useful features.
So, try to treat LSP as a serialization format, not as an internal data model.
And try to write more about how to implement language servers&#8201;&#8212;&#8201;I feel like there&#8217;s still not enough knowledge about this out there.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>That&#8217;s it!</p>
</div>
<hr>
<div class="paragraph">
<p>P.S. If by any chance you are benefiting from using rust-analyzer, consider sponsoring <a href="https://opencollective.com/rust-analyzer">Ferrous Systems Open Source Collective for rust-analyzer</a> to support its development!</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[LSP (language server protocol) is fairly popular today. There&#8217;s a standard explanation of why that is the case. You probably have seen this picture before:]]></summary></entry><entry><title type="html">Self Modifying Code</title><link href="https://matklad.github.io//2022/03/26/self-modifying-code.html" rel="alternate" type="text/html" title="Self Modifying Code" /><published>2022-03-26T00:00:00+00:00</published><updated>2022-03-26T00:00:00+00:00</updated><id>https://matklad.github.io//2022/03/26/self-modifying-code</id><content type="html" xml:base="https://matklad.github.io//2022/03/26/self-modifying-code.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This post has nothing to do with JIT-like techniques for patching machine code on the fly (though they are cool!).
Instead, it describes a cute/horrible trick/hack you can use to generate <em>source</em> code if you are not a huge fan of macros.
The final technique is going to be independent of any particular programming language, but the lead-up is going to be Rust-specific.
The pattern can be applied to a wide variety of tasks, but we&#8217;ll use a model problem to study different solutions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="problem"><a class="anchor" href="#problem"></a>Problem</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I have a field-less enum representing various error conditions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="n">AccountNotFound</span><span class="p">,</span>
  <span class="n">InsufficientBalance</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a type I expect to change fairly often.
I predict that it will grow a lot.
Even the initial version contains half a dozen variants already!
For brevity, I am showing only a subset here.</p>
</div>
<div class="paragraph">
<p>For the purposes of serialization, I would like to convert this error to and from an error code.
One direction is easy, there&#8217;s built in mechanism for this in Rust:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The other direction is more annoying: it isn&#8217;t handled by the language automatically yet (although there&#8217;s an in-progress PR which adds just that!), so we have to write some code ourselves:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
      <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InvalidSignature</span><span class="p">,</span>
      <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">AccountNotFound</span><span class="p">,</span>
      <span class="mi">2</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InsufficientBalance</span><span class="p">,</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, given that I expect this type to change frequently, this is asking for trouble!
It&#8217;s very easy for the <code>match</code> and the enum definition to get out of sync!</p>
</div>
<div class="paragraph">
<p>What should we do? What <em>can</em> we do?</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="minimalist-solution"><a class="anchor" href="#minimalist-solution"></a>Minimalist Solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now, seasoned Rust developers are probably already thinking about macros (or maybe even about specific macro crates).
And we&#8217;ll get there!
But first, let&#8217;s see how I usually solve the problem, when (as I am by default) I am not keen on adding macros.</p>
</div>
<div class="paragraph">
<p>The idea is to trick the compiler into telling us the number of elements in the enum, which would allow us to implement some sanity checking.
We can do this by adding a fake element at the end of the enum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="n">AccountNotFound</span><span class="p">,</span>
  <span class="n">InsufficientBalance</span><span class="p">,</span>
  <span class="n">__LAST</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">ALL</span><span class="p">:</span> <span class="p">[</span><span class="n">Error</span><span class="p">;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">__LAST</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="nn">Error</span><span class="p">::</span><span class="n">InvalidSignature</span><span class="p">,</span>
    <span class="nn">Error</span><span class="p">::</span><span class="n">AccountNotFound</span><span class="p">,</span>
    <span class="nn">Error</span><span class="p">::</span><span class="n">InsufficientBalance</span><span class="p">,</span>
  <span class="p">];</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">Error</span><span class="p">::</span><span class="n">ALL</span><span class="nf">.get</span><span class="p">(</span><span class="n">code</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span><span class="nf">.copied</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="nn">Error</span><span class="p">::</span><span class="n">ALL</span>
      <span class="nf">.into_iter</span><span class="p">()</span>
      <span class="nf">.position</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="n">it</span> <span class="o">==</span> <span class="k">self</span><span class="p">)</span>
      <span class="nf">.unwrap_or_default</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, if we add a new error variant, but forget to update the <code>ALL</code> array, the code will fail to compile&#8201;&#8212;&#8201;exactly the reminder we need.
The major drawback here is that <code>__LAST</code> variant has to exist.
This is fine for internal stuff, but something not really great for a public, clean API.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="minimalist-macro"><a class="anchor" href="#minimalist-macro"></a>Minimalist Macro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now, let&#8217;s get to macros, and let&#8217;s start with the simplest possible one I can think of!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="nd">define_error!</span><span class="p">[</span>
  <span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="n">AccountNotFound</span><span class="p">,</span>
  <span class="n">InsufficientBalance</span><span class="p">,</span>
<span class="p">];</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Pretty simple, heh? Let&#8217;s look at the definition of <code>define_error!</code> though:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="nd">macro_rules!</span> <span class="n">define_error</span> <span class="p">{</span>
  <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$err:ident</span><span class="p">,)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
      <span class="nv">$</span><span class="p">(</span><span class="nv">$err</span><span class="p">,)</span><span class="o">*</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">#![allow(non_upper_case_globals)]</span>
        <span class="nv">$</span><span class="p">(</span><span class="k">const</span> <span class="nv">$err</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="nn">Error</span><span class="p">::</span><span class="nv">$err</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;)</span><span class="o">*</span>
        <span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
          <span class="nv">$</span><span class="p">(</span><span class="nv">$err</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nv">$err</span><span class="p">),)</span><span class="o">*</span>
          <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s &#8230;&#8203; quite literally a puzzle!
Declarative macro machinery is comparatively inexpressive, so you need to get creative to get what you want.
Here, ideally I&#8217;d write</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
  <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">AccountNotFound</span><span class="p">,</span>
  <span class="mi">2</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InsufficientBalance</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alas, counting in macro by example is possible, but not trivial.
It&#8217;s a subpuzle!
Rather than solving it, I use the following work-around:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">const</span> <span class="n">InvalidSignature</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InvalidSignature</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
<span class="k">match</span> <span class="p">{</span>
  <span class="n">InvalidSignature</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InvalidSignature</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And then I have to <code>#![allow(non_upper_case_globals)]</code>, to prevent the compiler from complaining.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="idiomatic-macro"><a class="anchor" href="#idiomatic-macro"></a>Idiomatic Macro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The big problem with macro is that it&#8217;s not only the internal implementation which is baroque!
The call-site is pretty inscrutable as well!
Let&#8217;s imagine we are new to a codebase, and come across the following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="nd">define_error!</span><span class="p">[</span>
  <span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="n">AccountNotFound</span><span class="p">,</span>
  <span class="n">InsufficientBalance</span><span class="p">,</span>
<span class="p">];</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The question I would ask here would be &#8220;what&#8217;s that <code>Error</code> thing is?&#8221;.
Luckily, we live in the age of powerful IDEs, so we can just &#8220;goto definition&#8221; to answer that, right?</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="/assets/gotodef-macro-1.gif" alt="gotodef macro 1">
</div>
</div>
<div class="paragraph">
<p>Well, not really.
An IDE says that the <code>Error</code> token is produced by <em>something</em> inside that macro invocation.
That&#8217;s a correct answer, if not the most useful one!
So I have to read the definition of the <code>define_error</code> macro and understand how that works internally to get the idea about public API available externally (e.g., that the <code>Error</code> refers to a public enum).
And here the puzzler nature of declarative macros is exacerbated.
It&#8217;s hard enough to figure out how to express the idea you want using the restricted language of macros.
It&#8217;s doubly hard to understand the idea the macro&#8217;s <em>author</em> had when you can&#8217;t peek inside their brain and observer only to the implementation of the macro.</p>
</div>
<div class="paragraph">
<p>One remedy here is to make macro input look more like the code we want to produce.
Something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="nd">define_error!</span><span class="p">[</span>
  <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
  <span class="k">pub</span> <span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
    <span class="n">InvalidSignature</span><span class="p">,</span>
    <span class="n">AccountNotFound</span><span class="p">,</span>
    <span class="n">InsufficientBalance</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">];</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This indeed is marginally friendlier for IDEs and people to make sense of:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="/assets/gotodef-macro-2.gif" alt="gotodef macro 2">
</div>
</div>
<div class="paragraph">
<p>The cost for this is a more complicated macro implementation.
Generally, a macro needs to do two things: parse arbitrary token stream input, and emit valid Rust code as output.
Parsing is usually the more complicated task.
That&#8217;s why in our minimal attempt we used maximally simple syntax, just a list of identifiers.
However, if we want to make the input of the macro look more like Rust, we have to parse a subset of Rust, and that&#8217;s more involved:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="nd">macro_rules!</span> <span class="n">define_error</span> <span class="p">{</span>
  <span class="p">(</span>
    <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">meta:meta]</span><span class="p">)</span><span class="o">*</span>
    <span class="nv">$vis:vis</span> <span class="k">enum</span> <span class="nv">$Error:ident</span> <span class="p">{</span>
      <span class="nv">$</span><span class="p">(</span><span class="nv">$err:ident</span><span class="p">,)</span><span class="o">*</span>
    <span class="p">}</span>
  <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">meta]</span><span class="p">)</span><span class="o">*</span>
    <span class="nv">$vis</span> <span class="k">enum</span> <span class="nv">$Error</span> <span class="p">{</span>
      <span class="nv">$</span><span class="p">(</span><span class="nv">$err</span><span class="p">,)</span><span class="o">*</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">#![allow(non_upper_case_globals)]</span>
        <span class="nv">$</span><span class="p">(</span><span class="k">const</span> <span class="nv">$err</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="nv">$Error</span><span class="p">::</span><span class="nv">$err</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;)</span><span class="o">*</span>
        <span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
          <span class="nv">$</span><span class="p">(</span><span class="nv">$err</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nv">$Error</span><span class="p">::</span><span class="nv">$err</span><span class="p">),)</span><span class="o">*</span>
          <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nd">define_error!</span><span class="p">[</span>
  <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
  <span class="k">pub</span> <span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
    <span class="n">InvalidSignature</span><span class="p">,</span>
    <span class="n">AccountNotFound</span><span class="p">,</span>
    <span class="n">InsufficientBalance</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">];</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We have to carefully deal with all those visibilities and attributes.
Even after we do that, the connection between the input Rust-like syntax and the output Rust is skin-deep.
This is mostly smoke and mirrors, and is not much different from, e.g., using Haskell syntax here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="nd">macro_rules!</span> <span class="n">define_error</span> <span class="p">{</span>
  <span class="p">(</span>
    <span class="n">data</span> <span class="nv">$Error:ident</span> <span class="o">=</span> <span class="nv">$err0:ident</span> <span class="nv">$</span><span class="p">(|</span> <span class="nv">$err:ident</span><span class="p">)</span><span class="o">*</span>
      <span class="nv">$</span><span class="p">(</span><span class="nf">deriving</span> <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$derive:ident</span><span class="p">),</span><span class="o">*</span><span class="p">))</span><span class="o">?</span>
  <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="nv">$</span><span class="p">(</span><span class="nd">#[derive(</span><span class="err">$</span><span class="nd">(</span><span class="err">$</span><span class="nd">derive),</span><span class="err">*</span><span class="nd">)]</span><span class="p">)</span><span class="o">?</span>
    <span class="k">enum</span> <span class="nv">$Error</span> <span class="p">{</span>
      <span class="nv">$err0</span><span class="p">,</span>
      <span class="nv">$</span><span class="p">(</span><span class="nv">$err</span><span class="p">,)</span><span class="o">*</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">#![allow(non_upper_case_globals)]</span>
        <span class="k">const</span> <span class="nv">$err0</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="nv">$Error</span><span class="p">::</span><span class="nv">$err0</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
        <span class="nv">$</span><span class="p">(</span><span class="k">const</span> <span class="nv">$err</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="nv">$Error</span><span class="p">::</span><span class="nv">$err</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;)</span><span class="o">*</span>
        <span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
          <span class="nv">$err0</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nv">$Error</span><span class="p">::</span><span class="nv">$err0</span><span class="p">),</span>
          <span class="nv">$</span><span class="p">(</span><span class="nv">$err</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nv">$Error</span><span class="p">::</span><span class="nv">$err</span><span class="p">),)</span><span class="o">*</span>
          <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nd">define_error!</span><span class="p">[</span>
  <span class="n">data</span> <span class="n">Error</span> <span class="o">=</span> <span class="n">InvalidSignature</span> <span class="p">|</span> <span class="n">AccountNotFound</span> <span class="p">|</span> <span class="n">InsufficientBalance</span>
    <span class="nf">deriving</span> <span class="p">(</span><span class="n">Debug</span><span class="p">,</span> <span class="nb">Clone</span><span class="p">,</span> <span class="nb">Copy</span><span class="p">,</span> <span class="nb">PartialEq</span><span class="p">,</span> <span class="nb">Eq</span><span class="p">)</span>

<span class="p">];</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="attribute-macro"><a class="anchor" href="#attribute-macro"></a>Attribute Macro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We can meaningfully increase the fidelity between macro input and macro output by switching to a derive macro.
In contrast to function-like macros, derives require that their input is syntactically and even semantically valid Rust.</p>
</div>
<div class="paragraph">
<p>So the result looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">macros</span><span class="p">::</span><span class="n">FromCode</span><span class="p">;</span>

<span class="nd">#[derive(FromCode,</span> <span class="nd">Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="n">AccountNotFound</span><span class="p">,</span>
  <span class="n">InsufficientBalance</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, the <code>enum Error</code> here is an honest, simple enum!
It&#8217;s not an alien beast which just wears enum&#8217;s skin.</p>
</div>
<div class="paragraph">
<p>And the implementation of the macro doesn&#8217;t look too bad either, thanks to @dtolnay&#8217;s tasteful API design:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">quote</span><span class="p">::</span><span class="n">quote</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">syn</span><span class="p">::{</span><span class="n">parse_macro_input</span><span class="p">,</span> <span class="n">DeriveInput</span><span class="p">};</span>

<span class="nd">#[proc_macro_derive(FromCode)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">input</span> <span class="k">as</span> <span class="n">DeriveInput</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">error_name</span> <span class="o">=</span> <span class="n">input</span><span class="py">.ident</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">enum_</span> <span class="o">=</span> <span class="k">match</span> <span class="n">input</span><span class="py">.data</span> <span class="p">{</span>
    <span class="nn">syn</span><span class="p">::</span><span class="nn">Data</span><span class="p">::</span><span class="nf">Enum</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"expected an enum"</span><span class="p">),</span>
  <span class="p">};</span>

  <span class="k">let</span> <span class="n">arms</span> <span class="o">=</span>
    <span class="n">enum_</span><span class="py">.variants</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">var</span><span class="p">)|</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">var_name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">var</span><span class="py">.ident</span><span class="p">;</span>
      <span class="nd">quote!</span> <span class="p">{</span>
        #<span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span>#<span class="nn">error_name</span><span class="p">::</span>#<span class="n">var_name</span><span class="p">),</span>
      <span class="p">}</span>
    <span class="p">});</span>

  <span class="nd">quote!</span> <span class="p">{</span>
    <span class="k">impl</span> #<span class="n">error_name</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span>#<span class="n">error_name</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
          #<span class="p">(</span>#<span class="n">arms</span><span class="p">)</span><span class="o">*</span>
          <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike declarative macros, here we just directly express the syntax that we want to emit&#8201;&#8212;&#8201;a match over consecutive natural numbers.</p>
</div>
<div class="paragraph">
<p>The biggest drawback here is that on the call-site now we don&#8217;t have <em>any</em> idea about the extra API generated by the macro.
If, with declarative macros, you can notice an <code>pub fn from_code</code> in the same file and guess that that&#8217;s a part of an API, with a procedural macro that string is in a completely different crate!
While proc-macro can greatly improve the ergonomics of using and implementing macros (inflated compile times notwithstanding), for the reader, they are arguably even more opaque than declarative macros.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="self-modifying-code"><a class="anchor" href="#self-modifying-code"></a>Self Modifying Code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Finally, let&#8217;s see the promised hacky solution :)
While, as you might have noticed, I am not a huge fan of macros, I like plain old code generation&#8201;&#8212;&#8201;text in, text out.
Text manipulation is much worse-is-betterer than advanced macro systems.</p>
</div>
<div class="paragraph">
<p>So what we are going to do is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Read the file with the enum definition as a string (<code>file!()</code> macro will be useful here).</p>
</li>
<li>
<p>&#8220;Parse&#8221; enum definition using unsophisticated string splitting (<code>str::split_once</code>, aka <code>cut</code> would be our parser).</p>
</li>
<li>
<p>Generate the code we want by concatenating strings.</p>
</li>
<li>
<p>Paste the resulting code into a specially marked position.</p>
</li>
<li>
<p>Overwrite the file in place, if there are changes.</p>
</li>
<li>
<p>And we are going to use a <code>#[test]</code> to drive the process!</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="n">InsufficientBalance</span><span class="p">,</span>
  <span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="n">AccountNotFound</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
      <span class="c1">// region:sourcegen</span>
      <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InsufficientBalance</span><span class="p">,</span>
      <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InvalidSignature</span><span class="p">,</span>
      <span class="mi">2</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">AccountNotFound</span><span class="p">,</span>
      <span class="c1">// endregion:sourcegen</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">sourcegen_from_code</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">original_text</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="nd">file!</span><span class="p">())</span><span class="nf">.unwrap</span><span class="p">();</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">variants</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span>
    <span class="nf">split_twice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">original_text</span><span class="p">,</span> <span class="s">"pub enum Error {</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"}"</span><span class="p">)</span>
      <span class="nf">.unwrap</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">arms</span> <span class="o">=</span> <span class="n">variants</span>
    <span class="nf">.lines</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.trim_end_matches</span><span class="p">(</span><span class="sc">','</span><span class="p">))</span>
    <span class="nf">.enumerate</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">var</span><span class="p">)|</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"      {i} =&gt; Error::{var},</span><span class="se">\n</span><span class="s">"</span><span class="p">))</span>
    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">new_text</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">start_marker</span> <span class="o">=</span> <span class="s">"      // region:sourcegen</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">end_marker</span> <span class="o">=</span> <span class="s">"      // endregion:sourcegen</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span> <span class="o">=</span>
      <span class="nf">split_twice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">original_text</span><span class="p">,</span> <span class="n">start_marker</span><span class="p">,</span> <span class="n">end_marker</span><span class="p">)</span>
        <span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"{prefix}{start_marker}{arms}{end_marker}{suffix}"</span><span class="p">)</span>
  <span class="p">};</span>

  <span class="k">if</span> <span class="n">new_text</span> <span class="o">!=</span> <span class="n">original_text</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nf">write</span><span class="p">(</span><span class="nd">file!</span><span class="p">(),</span> <span class="n">new_text</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">panic!</span><span class="p">(</span><span class="s">"source was not up-to-date"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">split_twice</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">text</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
  <span class="n">start_marker</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
  <span class="n">end_marker</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="o">=</span> <span class="n">text</span><span class="nf">.split_once</span><span class="p">(</span><span class="n">start_marker</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span> <span class="o">=</span> <span class="n">rest</span><span class="nf">.split_once</span><span class="p">(</span><span class="n">end_marker</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="nf">Some</span><span class="p">((</span><span class="n">prefix</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">suffix</span><span class="p">))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s the whole pattern!
Note how, unlike every other solution, it is crystal clear how the generated code works.
It&#8217;s just code which you can goto-definition, or step through in debugging.
You can be completely oblivious about the shady <code>#[test]</code> machinery, and that won&#8217;t harm understanding in any way.</p>
</div>
<div class="paragraph">
<p>The code of the &#8220;macro&#8221; is also easy to understand&#8201;&#8212;&#8201;that&#8217;s literally string manipulation.
What&#8217;s more, you can easily see how it works by just running the test!</p>
</div>
<div class="paragraph">
<p>The &#8220;read and update your own source code&#8221; part is a bit mind-bending!
But the implementation is tiny and only uses the standard library, so it should be easy to understand.</p>
</div>
<div class="paragraph">
<p>Unlike macros, this doesn&#8217;t try to enforce at compile time that the generated code is fresh.
If you update the <code>Error</code> definition, you need to re-run test for the generated code to be updated as well.
But this <em>will</em> be caught by the tests.
Note the important detail&#8201;&#8212;&#8201;the test only tries to update the source code if there are, in fact, changes.
That is, writable <code>src/</code> is required only during development.</p>
</div>
<div class="paragraph">
<p>That&#8217;s all, hope this survey was useful! Discussion on <a href="https://old.reddit.com/r/rust/comments/tp8tmn/blog_post_self_modifying_code/">/r/rust</a>.</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[This post has nothing to do with JIT-like techniques for patching machine code on the fly (though they are cool!). Instead, it describes a cute/horrible trick/hack you can use to generate source code if you are not a huge fan of macros. The final technique is going to be independent of any particular programming language, but the lead-up is going to be Rust-specific. The pattern can be applied to a wide variety of tasks, but we&#8217;ll use a model problem to study different solutions.]]></summary></entry></feed>